[{"title":"CORS 跨域资源共享","url":"/2022/06/23/CORS%20%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/","content":"CORS 跨域资源共享一.为什么需要跨域考虑到浏览器的安全，采用了同源策略(Same-Origin Policy)，而为了请求不同域的资源产生了跨域问题\n\n同源策略：同源就是域名、协议、端口完全相同，例如http://a.com与https://a.com就不是同源的，因为协议不同\n\n二.CORS跨源域资源共享机制允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行。跨域资源共享(Cross-Origin Resource Share 简称CORS)，CORS是一个W3C标准，它允许浏览器向跨源服务器发出XMLHttpRequest请求，从而突破了ajax只能使用同源服务的局限性。\nCORS允许服务器声明哪些源站通过浏览器有权限访问哪些资源，并且对于那些对服务器可能产生副作用的HTTP请求，例如POST、DELETE请求等，浏览器必须首先使用OPTIONS方法发起一个预检请求(prelight request)，从而获知服务器是否允许该跨域请求。而且在预检请求的返回中，服务器端也可以通知客户端是否需要携带身份凭证，例如cookie等。\n\ntip：\nCORS请求失败浏览器会产生错误，但是为了安全，在JavaScript代码层面是无法获知到底具体是哪里出了问题。你只能查看浏览器的控制台以得知具体是哪里出现了错误。这一点需要额外注意，特别是在定位服务接口的问题时往往只能看到接口报错了，但是却看不到具体的错误信息，如果直接就去排查服务是否有问题就会绕远路浪费时间了。\n![image-20220620162015803](&#x2F;Users&#x2F;zonst&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220620162015803.png)\n\n三.CORS实现机制CORS标准新增了一组HTTP头字段来实现该机制。服务端通过设置相应的头部字段来控制是否允许该次跨域请求，如果服务端没有返回正确的响应头部，则请求方不会收到任何数据。\n请求Header\n\n\n\n头名\n值\n说明\n\n\n\nOrigin\n本次请求来自哪个源（协议 + 域名 + 端口）\n服务器根据这个值，决定是否同意这次请求。简单请求和预检请求均包含该Header\n\n\nAccess-Control-Request-Method\n请求方法列表\n预检请求时，该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法\n\n\nAccess-Control-Request-Headers\n额外的Headers\n该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段\n\n\n响应Header\n\n\n\n头名\n值\n说明\n\n\n\nAccess-Control-Allow-Origin\n该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。\n每次回应都必定包含的\n\n\nAccess-Control-Allow-Credentials\n该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认是false，不发送Cookie。\n设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。另外当该字段为true时，Access-Control-Allow-Origin字段不能是*，只能为Origin字段的值。\n\n\nAccess-Control-Expose-Headers\n该字段可选。\nCORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。\n\n\nAccess-Control-Allow-Methods\n预检请求返回字段，必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法\n返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。\n\n\nAccess-Control-Allow-Headers\n预检请求返回字段，如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。\n它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。\n\n\nAccess-Control-Max-Age\n预检请求返回字段，可选，用来指定本次预检请求的有效期，单位为秒。\n允许缓存该条回应Access-Control-Max-Age秒，在此期间，不用发出另一条预检请求。\n\n\n四.go代码实践使用gin自定义中间件实现\nfunc Cors() gin.HandlerFunc &#123;   return func(c *gin.Context) &#123;      method := c.Request.Method      origin := c.Request.Header.Get(&quot;Origin&quot;) //请求头部      if origin != &quot;&quot; &#123;         // 当Access-Control-Allow-Credentials为true时，将*替换为指定的域名         c.Header(&quot;Access-Control-Allow-Origin&quot;, &quot;http://a.com&quot;)          c.Header(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, PUT, DELETE, UPDATE&quot;)         c.Header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, X-Extra-Header, Content-Type, Accept, Authorization&quot;)         c.Header(&quot;Access-Control-Expose-Headers&quot;, &quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Cache-Control, Content-Language, Content-Type&quot;)         c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)         c.Header(&quot;Access-Control-Max-Age&quot;, &quot;86400&quot;) // 可选         c.Set(&quot;content-type&quot;, &quot;application/json&quot;) // 可选      &#125;      if method == &quot;OPTIONS&quot; &#123;         c.AbortWithStatus(http.StatusNoContent)      &#125;      c.Next()   &#125;&#125;func main() &#123;  r := gin.Default()  r.Use(Cors()) //开启中间件 允许使用跨域请求  // 其他路由设置  r.run()&#125;\n\n为了更复杂鉴权逻辑，使用beego的cros包实现\nimport (   &quot;github.com/beego/beego/v2&quot;  &quot;github.com/beego/beego/v2/server/web/filter/cors&quot;)func main() &#123;  // CORS for https://foo.* origins, allowing:  // - PUT and PATCH methods  // - Origin header  // - Credentials share  beego.InsertFilter(&quot;*&quot;, beego.BeforeRouter, cors.Allow(&amp;cors.Options&#123;   AllowOrigins:     []string&#123;&quot;https://*.foo.com&quot;&#125;,   AllowMethods:     []string&#123;&quot;PUT&quot;, &quot;PATCH&quot;&#125;,   AllowHeaders:     []string&#123;&quot;Origin&quot;&#125;,   ExposeHeaders:    []string&#123;&quot;Content-Length&quot;&#125;,   AllowCredentials: true,  &#125;))  beego.Run()&#125;\n\n","categories":["前端"],"tags":["CORS"]},{"title":"GO中的（...）用法","url":"/2022/06/23/GO%E4%B8%AD%E7%9A%84%EF%BC%88...%EF%BC%89%E7%94%A8%E6%B3%95/","content":"GO中的（…）用法1.函数中作为可变数量参数package mainimport &quot;fmt&quot;func main() &#123;    //multiParam 可以接受可变数量的参数    multiParam(&quot;jerry&quot;, &quot;herry&quot;)    names := []string&#123;&quot;jerry&quot;, &quot;herry&quot;&#125;    multiParam(names...)&#125;func multiParam(args ...string) &#123;    //接受的参数放在args数组中    for _, e := range args &#123;        fmt.Println(e)    &#125;&#125;\n\n当同时存在普通参数和可变参数时，将可变参数放在最右边\npackage mainimport &quot;fmt&quot;func main() &#123;   //multiParam 可以接受可变数量的参数   multiParam(&quot;jerry&quot;, 1)   multiParam(&quot;php&quot;, 1, 2)&#125;func multiParam(name string, args ...int) &#123;   fmt.Println(name)   //接受的参数放在args数组中   for _, e := range args &#123;      fmt.Println(e)   &#125;&#125;\n\n:pushpin:\n作为函数参数时：\n参数名 ...类型—&gt;args ...int\n作为变量传入时:\n函数名(切片...)—&gt;multiParam(names...)\n2.切片\ns如果使用s...符号解压缩切片，则可以将切片直接传递给可变参数函数。在这种情况下，不会创建新的切片。（类似传指针？）\n\npackage mainimport &quot;fmt&quot;func main() &#123;    //multiParam 可以接受可变数量的参数    names := []string&#123;&quot;jerry&quot;, &quot;herry&quot;&#125;    multiParam(names...)&#125;func multiParam(args ...string) &#123;    //接受的参数放在args数组中    for _, e := range args &#123;        fmt.Println(e)    &#125;&#125;\n\n​\t使用append合并slice\nstooges := []string&#123;&quot;Moe&quot;, &quot;Larry&quot;, &quot;Curly&quot;&#125;lang := []string&#123;&quot;php&quot;, &quot;golang&quot;, &quot;java&quot;&#125;stooges = append(stooges, lang...)fmt.Println(stooges)\n\n3.数组文字在不想写数组的长度时可以这样使用\nstooges := [...]string&#123;&quot;Moe&quot;, &quot;Larry&quot;, &quot;Curly&quot;&#125;arr := [...]int&#123;1, 2, 3&#125;fmt.Println(len(stooges))fmt.Println(len(arr))","categories":["后端"],"tags":["GO"]},{"title":"Ko js data-bind属性","url":"/2022/08/21/Knockout.js-1.data-bind%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%85%B3/","content":"Knockout.js常见data-bind属性\n\n\n属性\n意思\n补充\n\n\n\ntext\n文本的意思，这个绑定属性一般用于、、等标签显示文本，任何标签都可以使用这个绑定\n如果没有使用ko.observable()，则是静态绑定，否则是动态绑定\n\n\ninputText\ninput标签的文本\n相当于input标签的value属性\n\n\nvalue\n一般用于input标签，和inputText基本相似。只不过value更加规范。\n和value一起使用的还有一个参数valueUpdate，它表示界面做一个什么操作的时候更新该value。valueUpdate主要取值有change/keyup/keypress/afterkeydown等。分别表示文本变化、键盘缩起、键盘按下、键盘按下之后等操作时候更新value对应的viewmodel的值\n\n\nchecked\n绑定一般用于checkbox、radio等可以选中的表单元素，它对应的值是bool类型\n和value的用法基本相似\n\n\nenable\n绑定一般用于是否启用标签元素，一般用于表单元素的启用和禁用。和disabled相反，对应的值也是bool类型。\ndisabled与之用法相反\n\n\noptions\n上文中在使用select的绑定时候使用过options，它表示select标签的option的集合，对应的值为一个数组，表示这个下拉框的数据源\n可以使用observableArray启用对这个数据源的监控。\n\n\nhtml\ntext绑定实际上是对标签innerText的设置和取值，那么同理，html绑定也是对innerHTML的设置和取值\n它对应的值为一段html标签\n\n\ncss\ncss绑定是添加或删除一个或多个样式（class）到DOM元素上\n条件满足则生效\n\n\nstyle\nstyle绑定的作用是标签动态添加或移除某一个样式\n如果是添加或者移除多个，同css绑定的用法\n\n\nattr\nattr绑定主要用于向标签添加移除某一个或多个属性（包括自定义属性)\n同css用法\n\n\nclick\nclick绑定表示在对应的DOM元素上面添加点击事件的执行方法。可以在任意元素上面使用\n\n\n\n对应使用示例\ntext \n&gt;姓名：&lt;label data-bind=&quot;text:Name&quot;&gt;&lt;/label&gt;\n\ninputText\n&gt;职业：&lt;input type=&quot;text&quot; data-bind=&quot;textinput:Profession&quot;/&gt;\n\nvalue\n&gt;姓名：&lt;input type=&quot;text&quot; data-bind=&quot;value:Name,valueUpdate:&#x27;keyup&#x27;&quot; /&gt;\n\nenable(checked 类似)\n&gt;&lt;div&gt;   &lt;input type=&quot;text&quot; data-bind=&quot;enable:IsMen&quot;/&gt;&gt;&lt;/div&gt;&gt;&lt;script type=&quot;text/javascript&quot;&gt;   var myViewModel = &#123;       IsMen:ko.observable(true)   &#125;;   //2.激活绑定   ko.applyBindings(myViewModel);   myViewModel.IsMen(false);&gt;&lt;/script&gt;\n\noptions\n&gt;&lt;select data-bind=&quot;options:deptArr, optionsText:&#x27;Name&#x27;&quot;&gt;&lt;/select&gt;\n\ncss \n&gt;&lt;!--设置css--&gt;&gt;&lt;style type=&quot;text/css&quot;&gt;   .testbold &#123;       background-color:powderblue;   &#125;&gt;&lt;/style&gt;&gt;&lt;!--html代码  条件满足则css生效--&gt;&gt;&lt;div data-bind=&quot;css:&#123;testbold:myViewModel.Name()==&#x27;Lilei&#x27;&#125;&quot;&gt;   aaaa&gt;&lt;/div&gt;&gt;&lt;!--多个样式--&gt;&gt;&lt;div data-bind=&quot;css&#123;testbold:myViewModel.Name()==&#x27;Lilei&#x27;,               testborder:myViewModel.Profession()==&#x27;PHP工程师&#x27;&#125;&quot;&gt;   aaaa&gt;&lt;/div&gt;\n\nstyle\n&gt;&lt;div data-bind=&quot;style: &#123; color: currentProfit() &lt; 0 ? &#x27;red&#x27; : &#x27;black&#x27; &#125;&quot;&gt;  Profit Information&gt;&lt;/div&gt;\n\nattr\n&gt;&lt;a data-bind=&quot;attr: &#123; href: url, title: details &#125;&quot;&gt;   Report&gt;&lt;/a&gt;&gt;&lt;script type=&quot;text/javascript&quot;&gt;   var viewModel = &#123;       url: ko.observable(&quot;year-end.html&quot;),       details: ko.observable(&quot;Report including final year-end statistics&quot;)   &#125;;&gt;&lt;/script&gt;\n\nstyle\n&gt;&lt;div&gt;   &lt;input type=&quot;button&quot; value=&quot;测试click绑定&quot; data-bind=&quot;click:ClickFunc&quot; /&gt;&gt;&lt;/div&gt;&gt;&lt;!--ViewModel--&gt;&gt;var myViewModel = &#123;   ClickFunc:function()&#123;   \talert($(event.currentTarget).val());   &#125;&gt;&#125;;\n\n\n","categories":["前端"],"tags":["Knockout.js"]},{"title":"Jquery的相关 基础知识","url":"/2022/08/21/Jquery%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/","content":"\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript\n\n一、let、const、var声明变量的不同\nlet：声明为一个块级作用域的本地变量，并且可选的将其初始化为一个值。\nlet a;let name = &#x27;jack&#x27;;\n\nlet声明的变量有作用范围\n// i 不能被引用for (let i = 0; i &lt; 3; i++)&#123;    // i 可以被引用使用&#125;// i 不能被引用\n\nconst：声明一个不可变的常量\n\nvar：常见的变量声明方式，未对其赋值的情况下，默认类型为underfined，即未定义类型\n// i 能被引用for (var i = 0; i &lt; 3; i++)&#123;    // i 在整个函数都可以被引用&#125;// i 能被引用\n\n二、Object对象\n可以理解为“名称 - 值”的形式(非键值对)，类似JAVA中的HashMap\n\n1.创建方法var obj = new Object();或者var obj = &#123;&#125;;\n\n一般选取第二种，被称为“对象字面量（object literal）”法，也是JSON格式的核心语法\nvar obj = &#123;    name: &quot;Carrot&quot;,    _for: &quot;Max&quot;,//&#x27;for&#x27; 是保留字之一，使用&#x27;_for&#x27;代替    details: &#123;        color: &quot;orange&quot;,        size: 12    &#125;&#125;\n\n2.链式(chain)法访问属性或赋值// 访问obj.details.color      // orangeobj._for               //Maxobj[&quot;details&quot;][&quot;size&quot;] // 12// 赋值obj.details.color = &quot;red&quot;obj[&quot;details&quot;][&quot;size&quot;] = 11\n\n\n**备注**在ES5后可以不使用双引号，即obj[details][size]\n\n三、数组1.创建方法// 传统方法var a = new Array()a[0] = &quot;a&quot;;a[1] = &quot;b&quot;;a.length; //2// 字面量方法var a = [&quot;a&quot;,&quot;b&quot;];a;length; //2 \n\nlength的值为索引的最大值+1，而非数组元素个数也即存在以下情况：\nvar a = [&quot;a&quot;,&quot;b&quot;];a[100] = &quot;k&quot;;a.length; // 101\n\n而试图访问一个不存在的数组索引时，会得到underfined\ntypeof(a[90]) //underfined\n\n2.遍历// 一般方法for (var i = 0; i &lt; a.length; i++) &#123;    // Do something with a[i]&#125;// ES5后的方法 for...offor (const currentValue of a) &#123;  // Do something with currentValue&#125;// 另一种方法是 for...in，这种方法不推荐，它遍历的是数组元素而非索引for (var i in a)&#123;    // a[i]&#125;// 同时也可以使用forEach()来操作数组a.forEach(function(currentValue, index, array)&#123;    // 使用currentValue 或使用 array[index]&#125;)\n\n3.Array方法\n\n\n方法名称\n描述\n\n\n\na.toString()\n返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔。\n\n\na.toLocaleString()\n根据宿主环境的区域设置，返回一个包含数组中所有元素的字符串，每个元素通过逗号分隔。\n\n\na.concat(item1[, item2[, ...[, itemN]]])\n返回一个数组，这个数组包含原先 a 和 item1、item2、……、itemN 中的所有元素。\n\n\na.join(sep)\n返回一个包含数组中所有元素的字符串，每个元素通过指定的 sep 分隔。\n\n\na.pop()\n删除并返回数组中的最后一个元素。\n\n\na.push(item1, ..., itemN)\n将 item1、item2、……、itemN 追加至数组 a。\n\n\na.reverse()\n数组逆序（会更改原数组 a）。\n\n\na.shift()\n删除并返回数组中第一个元素。\n\n\na.slice(start, end)\n返回子数组，以 a[start] 开头，以 a[end] 前一个元素结尾。\n\n\na.sort([cmpfn])\n依据可选的比较函数 cmpfn 进行排序，如果未指定比较函数，则按字符顺序比较（即使被比较元素是数字）。\n\n\na.splice(start, delcount[, item1[, ...[, itemN]]])\n从 start 开始，删除 delcount 个元素，然后插入所有的 item。\n\n\na.unshift(item1[, item2[, ...[, itemN]]])\n将 item 插入数组头部，返回数组新长度（考虑 undefined）。\n\n\n四、函数\n注意，函数没有返回值时，默认返回underfined\n\n1.函数参数function add(i,j)&#123;&#125;\n\n传入多于定义函数的参数，会自动忽略多余的参数\n2.传入不定的参数// 1.使用arguments的内部对象function add()&#123;    var sum = 0;    for (var i = 0, j = arguments.length; i &lt; j; i++) &#123;        sum += arguments[i];    &#125;    return sum;&#125;// 使用add(1,2,43,4);//不定参数个数/********************************************************/// 2.使用 ...variable的形式function avg(...args) &#123;  var sum = 0;  for (let value of args) &#123;    sum += value;  &#125;  return sum / args.length;&#125;// 使用avg(2, 3, 4, 5); // 3.5\n\n\n使用第二种方法时，存在传入一个数组时，函数就使用不了的情况，即avg(array)无效，而需要传入avg(array[0],array[1]等)，此时有两种解决方案:\n\n重写函数avg()\n使用avg.apply(null,array)的形式\n\n\n3.匿名函数var avg = function() &#123;    var sum = 0;    for (var i = 0, j = arguments.length; i &lt; j; i++) &#123;        sum += arguments[i];    &#125;    return sum / arguments.length;&#125;;\n\n在语义上和function avg()相同，匿名函数允许在任何地方定义函数，与C中的块级作用域类似\nvar a = 1;var b = 2;(function() &#123;    var b = 3;    a += b;&#125;)();a; // 4b; // 2\n\n自调用函数\n// 官方推荐写法(function ()&#123;   // do something &#125;());// demovar charsInBody = (function counter(elm) &#123;    if (elm.nodeType == 3) &#123; // 文本节点        return elm.nodeValue.length;    &#125;    var count = 0;    for (var i = 0, child; child = elm.childNodes[i]; i++) &#123;        count += counter(child);    &#125;    return count;&#125;)(document.body);\n\n五、自定义对象\nJavaScript是一种基于原型的编程语言，没有class语句，而是将函数用作类\n\n1.thisfunction makePerson(first, last) &#123;    return &#123;        first: first,        last: last,        fullName: function() &#123;            return this.first + &#x27; &#x27; + this.last;        &#125;,        fullNameReversed: function() &#123;            return this.last + &#x27;, &#x27; + this.first;        &#125;    &#125;&#125;s = makePerson(&quot;Simon&quot;, &quot;Willison&quot;);s.fullName(); // &quot;Simon Willison&quot;s.fullNameReversed(); // Willison, Simon\n\n在使用时，使用this关键字代指当前对象。\n而通常使用.或者[]访问属性或方法时，这个对象就变成了this对象，没用使用this则会指向全局对象(global object)，就会造成找不到对象，报错。\n2.prototypefunction Person(first, last) &#123;    this.first = first;    this.last = last;&#125;Person.prototype.fullName = function() &#123;    return this.first + &#x27; &#x27; + this.last;&#125;Person.prototype.fullNameReversed = function() &#123;    return this.last + &#x27;, &#x27; + this.first;&#125;\n\nPerson.prototype 是一个可以被Person的所有实例共享的对象。它是一个名叫原型链（prototype chain）的查询链的一部分：当你试图访问 Person 某个实例一个没有定义的属性时，解释器会首先检查这个 Person.prototype 来判断是否存在这样一个属性。所以，任何分配给 Person.prototype 的东西对通过 this 对象构造的实例都是可用的。\n运行时也能给对象添加额外的方法(甚至是内置的函数)\ns = new Person(&quot;Simon&quot;, &quot;Willison&quot;);s.firstNameCaps();  // TypeError on line 1: s.firstNameCaps is not a functionPerson.prototype.firstNameCaps = function() &#123;    return this.first.toUpperCase()&#125;s.firstNameCaps(); // SIMON\n\n3.内部函数\n对于嵌套函数而言，最外层函数定义的变量是可以被内部的函数全局共享的\n\nfunction parentFunc() &#123;  var a = 1;  function nestedFunc() &#123;    var b = 4; // parentFunc 无法访问 b    return a + b;  &#125;  return nestedFunc(); // 5&#125;\n\n六、闭包function makeAdder(a) &#123;  return function(b) &#123;    return a + b;  &#125;&#125;var add5 = makeAdder(5);   // a为5var add20 = makeAdder(20); // a为20add5(6); // ?  =&gt; 11add20(7); // ? =&gt; 27\n\n\n以下解释了为什么makeAdder(20)中20没有覆盖掉5\n\n每当 JavaScript 执行一个函数时，都会创建一个作用域对象（scope object），用来保存在这个函数中创建的局部变量。它使用一切被传入函数的变量进行初始化（初始化后，它包含一切被传入函数的变量）。这与那些保存的所有全局变量和函数的全局对象（global object）相类似，但仍有一些很重要的区别：\n第一，每次函数被执行的时候，就会创建一个新的，特定的作用域对象；\n第二，与全局对象（如浏览器的 window 对象）不同的是，你不能从 JavaScript 代码中直接访问作用域对象，也没有可以遍历当前作用域对象中的属性的方法。\n所以，当调用 makeAdder 时，解释器创建了一个作用域对象，它带有一个属性：a，这个属性被当作参数传入 makeAdder 函数。然后 makeAdder 返回一个新创建的函数（暂记为 adder）。通常，JavaScript 的垃圾回收器会在这时回收 makeAdder 创建的作用域对象（暂记为 b），但是，makeAdder 的返回值，新函数 adder，拥有一个指向作用域对象 b 的引用。最终，作用域对象 b 不会被垃圾回收器回收，直到没有任何引用指向新函数 adder。\n作用域对象组成了一个名为作用域链（scope chain）的（调用）链。它和 JavaScript 的对象系统使用的原型（prototype）链相类似。\n一个闭包，就是 一个函数 与其 被创建时所带有的作用域对象 的组合。闭包允许你保存状态——所以，它们可以用来代替对象。这个 StackOverflow 帖子里有一些关于闭包的详细介绍。\n","categories":["前端"],"tags":["Jquery"]},{"title":"ko js 属性绑定相关","url":"/2022/08/21/Knockout.js-2.%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%85%B3/","content":"Knockout.js三个监控属性–demo&lt;head&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt;    &lt;title&gt;TestKnockJs----监控属性&lt;/title&gt;\t&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt;\t&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/knockout/3.5.1/knockout-latest.min.js&quot;&gt;&lt;/script&gt;\t &lt;/head&gt;&lt;body&gt;\t&lt;h4&gt;Observables Demo 监控属性&lt;/h4&gt;    &lt;div&gt;         姓名：&lt;input data-bind=&quot;textinput:Name&quot;&gt;&lt;/input&gt;&lt;br /&gt;        职业：&lt;input type=&quot;text&quot; data-bind=&quot;textinput:Profession&quot; /&gt;    &lt;/div&gt;    &lt;div&gt;        输入修改姓名：&lt;input type=&quot;text&quot; id=&quot;txt_testobservable&quot; /&gt;    &lt;/div&gt;\t&lt;br&gt;\t&lt;h4&gt;DependentObservables Demo 监控依赖属性&lt;/h4&gt;\t 描述：&lt;label data-bind=&quot;text:Des&quot;&gt;&lt;/label&gt;\t&lt;br&gt;\t&lt;h4&gt;ObservableArray Demo 监控数组&lt;/h4&gt;\t&lt;div&gt;\t\t&lt;select data-bind=&quot;options:deptArr,optionsText:&#x27;Name&#x27;&quot;&gt;\t    &lt;/select&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;input type=&quot;text&quot; id=&quot;txt_observable&quot; /&gt;\t\t&lt;input type=&quot;button&quot; id=&quot;btn_test&quot; value=&quot;新增部门&quot; /&gt;    &lt;/div&gt; \t    &lt;script type=&quot;text/javascript&quot;&gt;\t\t    // 定义监控数组\t\t var deptArr = ko.observableArray([                &#123; id: 1, Name: &#x27;研发部&#x27; &#125;,                &#123; id: 2, Name: &#x27;行政部&#x27; &#125;,                &#123; id: 3, Name: &#x27;人事部&#x27; &#125;            ]);\t        //定义ViewModel        var myViewModel = &#123;            Name: ko.observable(&quot;jddpccz&quot;),            Profession: ko.observable(&quot;软件工程师&quot;),\t\t\tdeptArr: deptArr,        &#125;;\t\t\t\t// 监控依赖属性\t\tmyViewModel.Des = ko.dependentObservable(function () &#123;            return &quot;姓名：&quot; + myViewModel.Name() + &quot;，职业：&quot; + myViewModel.Profession();        &#125;);\t          //激活绑定        ko.applyBindings(myViewModel);        var i = 4        $(function () &#123;            //注册文本框的textchange事件            $(&quot;#txt_testobservable&quot;).on(&quot;input&quot;, function () &#123;                myViewModel.Name($(this).val());            &#125;);\t\t\t$(&quot;#btn_test&quot;).on(&quot;click&quot;, function () &#123;                    deptArr.push(&#123; id: i++, Name: $(&quot;#txt_observable&quot;).val() &#125;);                &#125;);        &#125;);    &lt;/script&gt;&lt;/body&gt;\n\n","categories":["前端"],"tags":["Knockout.js"]},{"title":"ko js json对象和监控属性的转化及关系","url":"/2022/06/23/Knockout.js-3.Json%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%9B%91%E6%8E%A7%E5%B1%9E%E6%80%A7%E7%9A%84%E8%BD%AC%E5%8C%96%E5%8F%8A%E5%85%B3%E7%B3%BB/","content":"Knockout.jsJson对象和监控属性的转化及关系\n1.Json对象转ViewModel\n简单demo–手动绑定\n\n$.ajax(&#123;    url: &quot;/Home/GetData&quot;,    type: &quot;get&quot;,    data: &#123;&#125;,    success: function (data, status) &#123; //成功执行数据的绑定设置        var oJson = data;        myViewModelJson.DeptName(oJson.DeptName);        myViewModelJson.DeptLevel(oJson.DetpLevel);        myViewModelJson.DeptDesc(oJson.DeptDesc);    &#125;&#125;);var myViewModelJson = &#123;    DeptName: ko.observable(),    DeptLevel: ko.observable(),    DeptDesc:ko.observable()&#125;;ko.applyBindings(myViewModelJson);\n\n\n进阶demo–使用组件简化绑定过程\nknockout.mapping\n引用需要在knockout.js后面\n\n$(function () &#123;    $.ajax(&#123;        url: &quot;/Home/GetData&quot;,        type: &quot;get&quot;,        data: &#123;&#125;,        success: function (data, status) &#123;            ko.mapping.fromJS(data, myViewModelJson)        &#125;    &#125;);&#125;);var myViewModelJson = &#123;    DeptName: ko.observable(),    DeptLevel: ko.observable(),    DeptDesc:ko.observable()&#125;;ko.applyBindings(myViewModelJson);\n\n\n2.ViewModel转换Json对象\nko原生\n\n\nko.toJS()：将 ViewModel 转换为 JSON 对象\nko.toJSON()：将 ViewModel 转换为序列化过的 Json string\n\n$(function () &#123;    var oJson1 = ko.toJS(myViewModelJson);    var oJson2 = ko.toJSON(myViewModelJson);&#125;);var myViewModelJson = &#123;    DeptName: ko.observable(&quot;研发部&quot;),    DeptLevel: ko.observable(&quot;2&quot;),    DeptDesc: ko.observable(&quot;开发一伙人&quot;)&#125;;ko.applyBindings(myViewModelJson);\n\n","categories":["前端"],"tags":["Knockout.js"]},{"title":"RPC 对比 RESTful","url":"/2022/06/23/RPC%20%E5%AF%B9%E6%AF%94%20RESTful/","content":"RPC 对比 RESTfulRPC 的消息传输可以通过 TCP、UDP 或者 HTTP等，所以有时候我们称之为RPC over TCP、 RPC over HTTP。RPC 通过 HTTP 传输消息的时候和 RESTful的架构是类似的，但是也有不同。\n:penguin:RPC over HTTP 与 RESTful对比\n首先，对比耦合度，参数顺序\n\nRPC 的客户端和服务器端是紧耦合的，客户端需要知道调用的过程的名字，过程的参数以及它们的类型、顺序等。一旦服务器更改了过程的实现，客户端的实现很容易出问题。\n\nRESTful基于 http的语义操作资源，参数的顺序一般没有关系，也很容易的通过代理转换链接和资源位置，从这一点上来说，RESTful 更灵活。\n\n\n其次，它们操作的对象不一样。 \n\nRPC 操作的是方法和过程，它要操作的是方法对象。 \nRESTful 操作的是资源(resource)，而不是方法。\n\n最后\n\nRESTful执行的是对资源的操作，增加、查找、修改和删除等,主要CURD，所以如果你要实现一个特定目的的操作，比如为名字姓张的学生的数学成绩都加上10这样的操作，RESTful的API设计起来就不是那么直观或者有意义。\n在这种情况下, RPC的实现更有意义，它可以实现一个 Student.Increment(Name, Score) 的方法供客户端调用。\n\n:truck:RPC over TCP 对比 RESTful\n如果我们直接使用socket实现 RPC，除了上面的不同外，我们可以获得性能上的优势。\n\nRPC over TCP可以通过长连接减少连接的建立所产生的花费，在调用次数非常巨大的时候(这是目前互联网公司经常遇到的情况,大并发的情况下)，这个花费影响是非常巨大的。\nRESTful 也可以通过 keep-alive 实现长连接， 但是它最大的一个问题是它的request-response模型是阻塞的 (http1.0和 http1.1, http 2.0没这个问题)，发送一个请求后只有等到response返回才能发送第二个请求 (有些http server实现了pipeling的功能，但不是标配)， RPC的实现没有这个限制。\n\n在当今用户和资源都是大数据大并发的趋势下，一个大规模的公司不可能使用一个单体程序提供所有的功能，微服务的架构模式越来越多的被应用到产品的设计和开发中，服务和服务之间的通讯也越发的重要， 所以 RPC 不失是一个解决服务之间通讯的好办法。\n","categories":["后端"],"tags":["RPC","RESTful"]},{"title":"RPC","url":"/2022/06/23/RPC/","content":"RPC\nhttps://ldbmcs.gitbook.io/java/fen-bu-shi-9/rpc/rpc-kuang-jia-dui-bi\nhttps://topgoer.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC.html\n\n一.简介\n远程过程调用（Remote Procedure Call，RPC）是一个计算机通信协议\n该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程\n如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用\n\n二.RPC框架对比一类是跟某种特定语言平台绑定的，另一类是与语言无关即跨语言平台的。\n跟语言平台绑定的开源 RPC 框架主要有下面几种。\n\nDubbo：国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 Java 语言。\nMotan：微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言。\nTars：腾讯内部使用的 RPC 框架，于 2017 年对外开源，仅支持 C++ 语言。\nSpring Cloud：国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 Java 语言\n\n而跨语言平台的开源 RPC 框架主要有以下几种。\n\ngRPC：Google 于 2015 年对外开源的跨语言 RPC 框架，支持多种语言。\nThrift：最初是由 Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持多种语言。\n\n三. RPC 框架，它们具体有何区别？3.1 Dubbo先来聊聊 Dubbo，Dubbo 可以说是国内开源最早的 RPC 框架了，目前只支持 Java 语言，它的架构可以用下面这张图展示。\n\n从图中你能看到，Dubbo 的架构主要包含四个角色，其中 Consumer 是服务消费者，Provider 是服务提供者，Registry 是注册中心，Monitor 是监控系统。\n具体的交互流程是 Consumer 一端通过注册中心获取到 Provider 节点后，通过 Dubbo 的客户端 SDK 与 Provider 建立连接，并发起调用。Provider 一端通过 Dubbo 的服务端 SDK 接收到 Consumer 的请求，处理后再把结果返回给 Consumer。\n3.2 MotanMotan 是国内另外一个比较有名的开源的 RPC 框架，同样也只支持 Java 语言实现，它的架构可以用下面这张图描述。\n\nMotan 与 Dubbo 的架构类似，都需要在 Client 端（服务消费者）和 Server 端（服务提供者）引入 SDK，其中 Motan 框架主要包含下面几个功能模块。\n\nregister：用来和注册中心交互，包括注册服务、订阅服务、服务变更通知、服务心跳发送等功能。\nprotocol：用来进行 RPC 服务的描述和 RPC 服务的配置管理，这一层还可以添加不同功能的 filter 用来完成统计、并发限制等功能。\nserialize：将 RPC 请求中的参数、结果等对象进行序列化与反序列化。\ntransport：用来进行远程通信，默认使用 Netty NIO 的 TCP 长链接方式。\ncluster：请求时会根据不同的高可用与负载均衡策略选择一个可用的 Server 发起远程调用。\n\n3.3 TarsTars 是腾讯根据内部多年使用微服务架构的实践，总结而成的开源项目，仅支持 C++ 语言，它的架构图如下。\n\nTars 的架构交互主要包括以下几个流程：\n\n服务发布流程：在 web 系统上传 server 的发布包到 patch，上传成功后，在 web 上提交发布 server 请求，由 registry 服务传达到 node，然后 node 拉取 server 的发布包到本地，拉起 server 服务。\n管理命令流程：web 系统上的可以提交管理 server 服务命令请求，由 registry 服务传达到 node 服务，然后由 node 向 server 发送管理命令。\n心跳上报流程：server 服务运行后，会定期上报心跳到 node，node 然后把服务心跳信息上报到 registry 服务，由 registry 进行统一管理。\n信息上报流程：server 服务运行后，会定期上报统计信息到 stat，打印远程日志到 log，定期上报属性信息到 prop、上报异常信息到 notify、从 config 拉取服务配置信息。\nclient 访问 server 流程：client 可以通过 server 的对象名 Obj 间接访问 server，client 会从 registry 上拉取 server 的路由信息（如 IP、Port 信息），然后根据具体的业务特性（同步或者异步，TCP 或者 UDP 方式）访问 server（当然 client 也可以通过 IP&#x2F;Port 直接访问 server）。\n\n3.4 Spring CloudSpring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。\n只支持 Java 语言平台，它的架构图可以用下面这张图来描述。\n\n由此可见，Spring Cloud 微服务架构是由多个组件一起组成的，各个组件的交互流程如下。\n\n请求统一通过 API 网关 Zuul 来访问内部服务，先经过 Token 进行安全认证。\n通过安全认证后，网关 Zuul 从注册中心 Eureka 获取可用服务节点列表。\n从可用服务节点中选取一个可用节点，然后把请求分发到这个节点。\n整个请求过程中，Hystrix 组件负责处理服务超时熔断，Turbine 组件负责监控服务间的调用和熔断相关指标，Sleuth 组件负责调用链监控，ELK 负责日志分析。\n\n3.5 gRPC先来看下 gRPC，它的原理是通过 IDL（Interface Definition Language）文件定义服务接口的参数和返回值类型，然后通过代码生成程序生成服务端和客户端的具体实现代码，这样在 gRPC 里，客户端应用可以像调用本地对象一样调用另一台服务器上对应的方法。\n\n它的主要特性包括三个方面。\n\n通信协议采用了 HTTP&#x2F;2，因为 HTTP&#x2F;2 提供了连接复用、双向流、服务器推送、请求优先级、首部压缩等机制。\nIDL 使用了ProtoBuf，ProtoBuf 是由 Google 开发的一种数据序列化协议，它的压缩和传输效率极高，语法也简单。\n多语言支持，能够基于多种语言自动生成对应语言的客户端和服务端的代码。\n\n3.6 Thrift再来看下 Thrift，Thrift 是一种轻量级的跨语言 RPC 通信方案，支持多达 25 种编程语言。为了支持多种语言，跟 gRPC 一样，Thrift 也有一套自己的接口定义语言 IDL，可以通过代码生成器，生成各种编程语言的 Client 端和 Server 端的 SDK 代码，这样就保证了不同语言之间可以相互通信。它的架构图可以用下图来描述。\n\n从这张图上可以看出 Thrift RPC 框架的特性。\n\n支持多种序列化格式：如 Binary、Compact、JSON、Multiplexed 等。\n支持多种通信方式：如 Socket、Framed、File、Memory、zlib 等。\n服务端支持多种处理方式：如 Simple 、Thread Pool、Non-Blocking 等。\n\n","categories":["后端"],"tags":["RPC"]},{"title":"docker部署静态网页","url":"/2022/07/23/docker%E9%83%A8%E7%BD%B2/","content":"一.docker部署静态网页在项目根目录下新建Dockerfile和docker-compose.yml文件\nDockerfile\n# 指定基础镜像FROM nginx # 把当前目录复制到./usr/share/nginx/html 也即nginx的默认html目录下COPY . ./usr/share/nginx/html\n\ndocker-compose.yml\nversion: &#x27;1&#x27; #版本services:  cardWeb:  #服务名    build: .  #从哪找到Dockerfile文件 .表示当前目录    image: jddpccz/webcard:last  #构建后的镜像名    ports:      - 80:80 #物理机端口 映射 虚拟机端口\n\n右击执行\n二.docker部署vue项目Dockerfile\nFROM node:lts-alpineWORKDIR /buildRUN npm set registry https://registry.npm.taobao.org# 提前复制，可以防止docker的缓存被破坏，节约npm install的时间COPY package.json /build/package.jsonRUN npm installCOPY ./ /buildRUN npm run buildFROM nginx# --from=0 从上一个镜像的目录下COPY --from=0 /build/dist /usr/share/nginx/htmlEXPOSE 80\n\ndocker-compose.yml\nversion: &#x27;2&#x27;services:  cardWeb-vue:  #服务名    build: .  #从哪找到Dockerfile文件 .表示当前目录    image: jddpccz/card-vue:last  #构建后的镜像名    ports:      - 80:80 #物理机端口 映射 虚拟机端口 注意-后空格\n\n.dockerignore (与.gitignore一样)\n.DS_Storenode_modules/dist# local env files.env.local.env.*.local# Log filesnpm-debug.log*yarn-debug.log*yarn-error.log*pnpm-debug.log*# Editor directories and files.idea.vscode*.suo*.ntvs**.njsproj*.sln*.sw?\n\n\n\n三.上传到阿里云镜像服务# 登录docker login --username=jddpccz registry.cn-chengdu.aliyuncs.com#上传docker tag jddpccz/card-vue:latest registry.cn-chengdu.aliyuncs.com/jddpccz/cards:latestdocker push registry.cn-chengdu.aliyuncs.com/jddpccz/cards:latest#pulldocker pull registry.cn-chengdu.aliyuncs.com/jddpccz/cards:[镜像版本号]#运行   -d 后台运行 -p端口映射 --name 容器名（cards） 后面是要运行的镜像名docker run -d -p 8003:80 --name cards registry.cn-chengdu.aliyuncs.com/jddpccz/cards","categories":["后端"],"tags":["docker"]},{"title":"go demo","url":"/2022/06/19/go-demo/","content":"go的相关例子1.guess_unmberpackage mainimport (\t&quot;fmt&quot;\t&quot;math/rand&quot;\t&quot;time&quot;)/**- 随机生成一个数字，输入一个数字看是否匹对，匹配则结速，反之提示是大了还是小了- 要求代码规范化- 每个函数不要超过80行，如果逻辑太复杂函数需要进行封装*/func main() &#123;\t// 用户输入的数\tvar num int\t// 随机生成的数\tvar rnum int\tfor true &#123;\t\trnum = randnum()\t\tfmt.Println(&quot;输入一个0-100的数，看你是否猜对随机生成的数，输入-1退出&quot;)\t\tfmt.Scanln(&amp;num)\t\t//fmt.Printf(&quot;输入%d&quot;, rnum)\t\tif num == -1 &#123;\t\t\treturn\t\t&#125;\t\tfor rnum != num &#123;\t\t\tif num &gt; rnum &#123;\t\t\t\tfmt.Println(&quot;猜大了&quot;)\t\t\t&#125; else if num &lt; rnum &#123;\t\t\t\tfmt.Println(&quot;猜小了&quot;)\t\t\t&#125;\t\t\tfmt.Scanln(&amp;num)\t\t&#125;\t\tfmt.Println(&quot;恭喜，猜对了&quot;)\t&#125;&#125;func randnum() int &#123;\trand.Seed(time.Now().Unix())\treturn rand.Intn(100)&#125;\n\n\n\n2.tree.gopackage main/**- 输入tree.exe能够以树状的形式当前目录下所有文件*/import (\t&quot;bufio&quot;\t&quot;fmt&quot;\t&quot;io/ioutil&quot;\t&quot;os&quot;)func getPath(path string, indent string) &#123;\tfiles, err := ioutil.ReadDir(path)\tif err != nil &#123;\t\tfmt.Println(&quot;read file path error&quot;, err)\t\treturn\t&#125;\t// 忽略以 . 开头的文件\tfor i := 0; i &lt; len(files); i++ &#123;\t\tif files[i].Name()[0] == &#x27;.&#x27; &#123;\t\t\t// 语法糖：...将一个切片或数组变成一个一个的元素,俗称将数组打散,用于append两个数组时\t\t\t// ar[:n]等价于a[0:n] 即初始化为0\t\t\t// ar[n:]等价于ar[n:len(ar)] 即默认为len(array/slice)\t\t\t// append 追加\t\t\tfiles = append(files[:i], files[i+1:]...)\t\t&#125;\t&#125;\t// 创建文件名数组\tdirs := make([]string, 0)\t// 先打印文件\tfor _, fi := range files &#123;\t\tif !fi.IsDir() &#123;\t\t\tdirs = append(dirs, fi.Name())\t\t&#125;\t&#125;\t// 记录文件个数\tlenFile := len(dirs)\t// 再打印文件夹\tfor _, fi := range files &#123;\t\tif fi.IsDir() &#123;\t\t\tdirs = append(dirs, fi.Name())\t\t&#125;\t&#125;\t// 最后一个文件的分支用 └── 表示, 更美观\tfor i := 0; i &lt; len(dirs); i++ &#123;\t\tif i == len(dirs)-1 &#123;\t\t\tfmt.Println(indent + &quot;└── &quot; + dirs[i])\t\t\tif i &gt;= lenFile &#123;\t\t\t\tgetPath(path+&quot;/&quot;+dirs[i], indent+&quot;   &quot;)\t\t\t&#125;\t\t&#125; else &#123;\t\t\tfmt.Println(indent + &quot;├── &quot; + dirs[i])\t\t\tif i &gt;= lenFile &#123;\t\t\t\tgetPath(path+&quot;/&quot;+dirs[i], indent+&quot;│  &quot;)\t\t\t&#125;\t\t&#125;\t&#125;&#125;func main() &#123;\tinputReader := bufio.NewReader(os.Stdin)\tfmt.Println(&quot;输入tree.exe查看当前目录文件&quot;)\tinput, er := inputReader.ReadString(&#x27;\\n&#x27;)\tif er != nil &#123;\t\tfmt.Println(&quot;read错误&quot;)\t\treturn\t&#125;\tswitch input &#123;\t// win下为 \\r\\n\tcase &quot;tree.exe\\n&quot;:\t\texPath, err := os.Getwd() // 获取程序执行的当前路径\t\tif err != nil &#123;\t\t\tfmt.Println(&quot;路径错误&quot;)\t\t&#125;\t\tfmt.Println(&quot;\\n当前运行目录：&quot;, exPath)\t\tgetPath(exPath, &quot;&quot;)\tdefault:\t\tfmt.Println(&quot;不支持其他输入&quot;)\t&#125;&#125;\n\n\n\n3.jjjbpackage main/**- 你有50枚⾦金金币，需要分配给以下⼏几个⼈人:- Matthew, Sarah, Augustus, Heidi, Emilie,Peter, Giana, Adriano, Aaron, Elizabeth。- 分配规则如下所示:- 名字中包含’a’或’A’: 1枚⾦金金币- 名字中包含’e’或’E’: 1枚⾦金金币- 名字中包含 ‘i’或’I’: 2枚⾦金金币- 名字中包含’o’或’O’: 3枚⾦金金币- 名字中包含’u’或’U’: 5枚⾦金金币写⼀一个程序，计算每个⽤用户分到了了多少⾦金金币，以及最后剩余多少⾦金金币?*/import (\t&quot;fmt&quot;\t&quot;strings&quot;)var (\tcoins = 50\tusers = []string&#123;\t\t&quot;Matthew&quot;, &quot;Sarah&quot;, &quot;Augustus&quot;, &quot;Heidi&quot;, &quot;Emilie&quot;, &quot;Peter&quot;, &quot;Giana&quot;, &quot;Adriano&quot;, &quot;Aaron&quot;, &quot;Elizabeth&quot;,\t&#125;\t// map\tdistribution = make(map[string]int, len(users)))func main() &#123;\tleft := dispatchCoin()\tfmt.Println(&quot;剩下：&quot;, left)\t// 打印各自的jjjb\tfor _, name := range users &#123;\t\tfmt.Printf(&quot;%s：%djjjb\\n&quot;, name, distribution[name])\t&#125;&#125;func dispatchCoin() int &#123;BREAK1:\tfor _, name := range users &#123;\t\t// strings.ToLower()函数接收一个字符串，\t\t// 并将字符串中的每个ASCII字符转换成小写，最后将新的字符串返回。\t\t// strings.Split函数用于将指定的分隔符切割字符串\t\t// 并返回切割后的字符串切片。\t\tnameSlice := strings.Split(strings.ToLower(name), &quot;&quot;)\t\tfor _, word := range nameSlice &#123;\t\t\tif coins == 0 &#123;\t\t\t\tfmt.Println(&quot;jjjb不足&quot;)\t\t\t\tbreak BREAK1\t\t\t&#125;\t\t\tswitch word &#123;\t\t\tcase &quot;a&quot;, &quot;e&quot;:\t\t\t\tif coins &gt;= 1 &#123;\t\t\t\t\tdistribution[name]++\t\t\t\t\tcoins--\t\t\t\t&#125;\t\t\tcase &quot;i&quot;:\t\t\t\tif coins &gt;= 2 &#123;\t\t\t\t\tdistribution[name] += 2\t\t\t\t\tcoins -= 2\t\t\t\t&#125;\t\t\tcase &quot;o&quot;:\t\t\t\tif coins &gt;= 3 &#123;\t\t\t\t\tdistribution[name] += 3\t\t\t\t\tcoins -= 3\t\t\t\t&#125;\t\t\tcase &quot;u&quot;:\t\t\t\tif coins &gt;= 5 &#123;\t\t\t\t\tdistribution[name] += 5\t\t\t\t\tcoins -= 5\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\treturn coins&#125;\n\n","categories":["后端"],"tags":["GO"]},{"title":"go中的相关知识","url":"/2022/06/23/go%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"1.结构体中的函数\n结构体函数可以用来模拟类的功能. google官方编程规范规定,包和结构体中变量名大写表示对外暴露,小写表示不对外暴露.相当于其他语言共有私有标识.此规则很多第三方接口遵守\n在函数名的前面申明\n\ntype Cat struct &#123;   Name    string   Age     int32   Address string&#125;func (cat *Cat) Grow() &#123;   cat.Age++&#125;func main() &#123;   myCat := Cat&#123;&quot;Little C&quot;, 2, &quot;In the house&quot;&#125;   myCat.Grow()   fmt.Printf(&quot;%v&quot;, myCat)&#125;&#123;Little C 3 In the house&#125;\n\n严格意义上来说,go没有属于结构体的函数.go函数有个特性,可以把函数归于任何类型(或任何类型的指针),相当于把函数的归属权付给了某人,某人可以直接调用函数\n如上面的例子中,函数把归属权给了结构体指针,结构体就可以调用这个函数,同时在函数内部使用这个结构体(结构体的名字当作this指针用)\n:zap:如果函数的归属的是结构体(而不是指针),那么结构体照样能用,但是结构体函数内修改将不能影响外部(传递的都是副本,但指针的副本解引用会是指向源对象)\ntype Handle int64func (h Handle)Show1(i int64) int64&#123;   h = 1   return i + int64(h)&#125;func (h *Handle) Show2(i int64) int64&#123;   *h = 2   return i + int64(*h)&#125;func main()  &#123;   var hand Handle = 0   fmt.Println(hand.Show1(100))   fmt.Println(hand)   fmt.Println(hand.Show2(100))   fmt.Println(hand)&#125;10101022\n\n2.go程我们称之为Go程是因为现有的术语—线程、协程、进程等等—无法准确传达它的含义。 \nGo程具有简单的模型：它是与其它Go程并发运行在同一地址空间的函数。它是轻量级的，所有消耗几乎就只有栈空间的分配。而且栈最开始是非常小的，所以它们很廉价， 仅在需要时才会随着堆空间的分配（和释放）而变化。\nGo程在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待I&#x2F;O， 那么其它的线程就会运行。Go程的设计隐藏了线程创建和管理的诸多复杂性。\n在函数或方法前添加 go 关键字能够在新的Go程中调用它。当调用完成后， 该Go程也会安静地退出。（效果有点像Unix Shell中的 &amp; 符号，它能让命令在后台运行。）\nfunc sum(a []int, c chan int) &#123;\tsum := 0\tfor _, v := range a &#123;\t\tsum += v\t&#125;\tc &lt;- sum //将和送入c,信道见下文&#125;func main() &#123;\ta := []int&#123;1, 2, 3, 4, 5, 6&#125;\tc := make(chan int)\tgo sum(a[len(a)/2:], c)\tgo sum(a[:len(a)/2], c)\tx, y := &lt;-c, &lt;-c //从c中获取\tfmt.Println(x,&quot;+&quot;, y,&quot;=&quot;, x+y)&#125;6 + 15 = 21\n\n3.信道信道与映射一样，也需要通过 make 来分配内存。其结果值充当了对底层数据结构的引用。 若提供了一个可选的整数形参，它就会为该信道设置缓冲区大小。默认值是零，表示不带缓冲的或同步的信道。\nci := make(chan int)            // 整数类型的无缓冲信道cj := make(chan int, 0)         // 整数类型的无缓冲信道cs := make(chan *os.File, 100)  // 指向文件指针的带缓冲信道\n\n无缓冲信道在通信时会同步交换数据，它能确保（两个Go程的）计算处于确定状态。\nc := make(chan int)  // 分配一个信道// 在Go程中启动排序。当它完成后，在信道上发送信号。go func() &#123;\tlist.Sort()\tc &lt;- 1  // 发送信号，什么值无所谓。&#125;()doSomethingForAWhile()&lt;-c   // 等待排序结束，丢弃发来的值。\n\n接收者在收到数据前会一直阻塞。\n\n若信道是不带缓冲的，那么在接收者收到值前， 发送者会一直阻塞；\n若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞； 若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。\n\n带缓冲的信道可被用作信号量，例如限制吞吐量。\n在下例中，进入的请求会被传递给 handle，它从信道中接收值，处理请求后将值发回该信道中，以便让该 “信号量”准备迎接下一次请求。信道缓冲区的容量决定了同时调用 process 的数量上限，因此我们在初始化时首先要填充至它的容量上限。\nvar sem = make(chan int, MaxOutstanding)\t// 定义好的maxfunc handle(r *Request) &#123;\tsem &lt;- 1 // 等待活动队列清空。\tprocess(r)  // 可能需要很长时间。\t&lt;-sem    // 完成；使下一个请求可以运行。&#125;func Serve(queue chan *Request) &#123;\tfor &#123;\t\treq := &lt;-queue\t\tgo handle(req)  // 无需等待 handle 结束。\t&#125;&#125;\n\n由于数据同步发生在信道的接收端（也就是说发送发生在&gt;接受之前，参见 Go内存模型），因此信号必须在信道的接收端获取，而非发送端。\n然而，它却有个设计问题：尽管只有 MaxOutstanding 个Go程能同时运行，但 Serve 还是为每个进入的请求都创建了新的Go程。其结果就是，若请求来得很快， 该程序就会无限地消耗资源。为了弥补这种不足，我们可以通过修改 Serve 来限制创建Go程，这是个明显的解决方案，但要当心我们修复后出现的Bug。\nfunc Serve(queue chan *Request) &#123;\tfor req := range queue &#123;\t\tsem &lt;- 1\t\tgo func() &#123;\t\t\tprocess(req) // 这儿有Bug，解释见下。\t\t\t&lt;-sem\t\t&#125;()\t&#125;&#125;\n\nBug出现在Go的 for 循环中，该循环变量在每次迭代时会被重用，因此 req 变量会在所有的Go程间共享，这不是我们想要的。我们需要确保 req 对于每个Go程来说都是唯一的。有一种方法能够做到，就是将 req 的值作为实参传入到该Go程的闭包中：\nfunc Serve(queue chan *Request) &#123;\tfor req := range queue &#123;\t\tsem &lt;- 1\t\tgo func(req *Request) &#123;\t\t\tprocess(req)\t\t\t&lt;-sem\t\t&#125;(req)\t&#125;&#125;\n\n比较前后两个版本，观察该闭包声明和运行中的差别。 另一种解决方案就是以相同的名字创建新的变量，如例中所示：\nfunc Serve(queue chan *Request) &#123;\tfor req := range queue &#123;\t\treq := req // 为该Go程创建 req 的新实例。\t\tsem &lt;- 1\t\tgo func() &#123;\t\t\tprocess(req)\t\t\t&lt;-sem\t\t&#125;()\t&#125;&#125;\n\n它的写法看起来有点奇怪\nreq := req\n\n但在Go中这样做是合法且惯用的。你用相同的名字获得了该变量的一个新的版本， 以此来局部地刻意屏蔽循环变量，使它对每个Go程保持唯一。\n回到编写服务器的一般问题上来。另一种管理资源的好方法就是启动固定数量的 handle Go程，一起从请求信道中读取数据。Go程的数量限制了同时调用 process 的数量。Serve 同样会接收一个通知退出的信道， 在启动所有Go程后，它将阻塞并暂停从信道中接收消息。\nfunc handle(queue chan *Request) &#123;\tfor r := range queue &#123;\t\tprocess(r)\t&#125;&#125;func Serve(clientRequests chan *Request, quit chan bool) &#123;\t// 启动处理程序\tfor i := 0; i &lt; MaxOutstanding; i++ &#123;\t\tgo handle(clientRequests)\t&#125;\t&lt;-quit  // 等待通知退出。&#125;\n\n4.数据类型转换\n\n\n转换 👇\nstring\nint\nfloat\nbool\nbyte\n\n\n\nfloat\nstrconv.ParseFloat()\nfloat(i)\n\nfloat(i)\nencoding&#x2F;binary包相互转换\n\n\nint\nstrconv.ParseInt()\n\nint(i)\nint(i)\nencoding&#x2F;binary包相互转换\n\n\nbool\nstrconv.ParseBool()\nbool(i)\nbool(i)\n\nencoding&#x2F;binary包相互转换\n\n\nstring\n\n1.通过Itoa方法转换  str1 :&#x3D; strconv.Itoa(i)  2.通过Sprintf方法转换   str2 :&#x3D; fmt.Sprintf(“%d”, i)  3.通过FormatInt转换str3 &#x3D; strconv.FormatInt()\n1.通过Itoa方法转换   str1 :&#x3D; strconv.Itof(f)  2.通过Sprintf方法转换   str2 :&#x3D; fmt.Sprintf(“%f”, f)  3.通过FormatInt转换 str3 &#x3D; strconv.FormatFloat()\n1.通过Sprintf方法转换          str2 :&#x3D; fmt.Sprintf(“%d”, b)  2. 通过FormatInt转换str3 &#x3D; strconv.FormatBool()\nstring(byte)\n\n\n5.type关键字1. 定义结构体//结构体定义type person struct &#123;   name string //注意后面不能有逗号   age  int&#125;func main() &#123;   //结构体初始化   p := person&#123;      name: &quot;taozs&quot;, //注意后面要加逗号      age:  18, //或者下面的&#125;提到这儿来可以省略逗号   &#125;   fmt.Println(p.name)&#125;//初始化字段不一定要全部指定，比如下面也是可以的，name默认取长度为0的空字符串p := person&#123;   age: 18,&#125;\n\n2.类型等价定义，类似取别名type name stringname类型与string等价例子：type name stringfunc main() &#123;   var myname name = &quot;taozs&quot; //其实就是字符串类型   l := []byte(myname) //字符串转字节数组   fmt.Println(len(l)) //字节长度&#125;不过，要注意的是，type绝不只是用于定义一系列的别名。还可以针对新类型定义方法。上面的name类型可以像下面这样定义方法：type name stringfunc (n name) len() int &#123;   return len(n)&#125;func main() &#123;   var myname name = &quot;taozs&quot; //其实就是字符串类型   l := []byte(myname) //字符串转字节数组   fmt.Println(len(l)) //字节长度   fmt.Println(myname.len()) //调用对象的方法&#125;\n\n3.结构体内嵌匿名成员//结构体内嵌匿名成员定义type person struct &#123;   string //直接写类型，匿名   age int&#125;func main() &#123;   //结构体匿名成员初始化   p := person&#123;string: &quot;taozs&quot;, age: 18&#125;//可以省略部分字段，如：person&#123;string: &quot;taozs&quot;&#125;。也可以这样省略字段名：person&#123;“taozs”, 18&#125;，但必须写全了，不可以省略部分字段   //结构体匿名成员访问   fmt.Println(p.string) //注意不能用强制类型转换（类型断言）：p.(string)&#125;以下是只有单个匿名成员的例子。//结构体内嵌匿名成员定义type person struct &#123;   string&#125;func main() &#123;   //结构体匿名成员初始化   p := person&#123;string: &quot;taozs&quot;&#125; //也可这样：person&#123;&quot;taozs&quot;&#125;   //结构体匿名成员访问   fmt.Println(p.string) //注意不能用强制类型转换（类型断言）：p.(string)&#125;\n\n4.定义接口类型//接口定义type Personer interface &#123;   Run()   Name() string&#125;//实现接口，注意实现接口的不一定只是结构体，也可以是函数对象，参见下面第5条type person struct &#123;   name string   age  int&#125;func (person) Run() &#123;   fmt.Println(&quot;running...&quot;)&#125;//接收参数person不可以是指针类型，否则不认为是实现了接口func (p person) Name() string &#123;   return p.name&#125;func main() &#123;//接口类型的变量定义var p Personer   fmt.Println(p) //值&lt;nil&gt;      //实例化结构体，并赋值给interface   p = person&#123;&quot;taozs&quot;, 18&#125; //或者：&amp;person&#123;&quot;taozs&quot;, 18&#125;   p.Run()   fmt.Println(p.Name())      var p2 person = p.(person) //类型断言，接口类型断言到具体类型   fmt.Println(p2.age)&#125;//另外，类型断言返回值也可以有第二个bool值，表示断言是否成功，如下：if p2, ok := p.(person); ok &#123;//断言成功ok值为true   fmt.Println(ok)   fmt.Println(p2.age)&#125;\n\n5.定义函数类型//以下是定义一个函数类型handlertype handler func (name string) int//针对这个函数类型可以再定义方法，如：func (h handler) add(name string) int &#123;   return h(name) + 10&#125;//下面让我们详细看一下例子，其中涉及了函数、函数的方法、结构体方法、接口的使用。package mainimport (   &quot;fmt&quot;)//定义接口type adder interface &#123;   add(string) int&#125;//定义函数类型type handler func (name string) int//实现函数类型方法func (h handler) add(name string) int &#123;   return h(name) + 10&#125;//函数参数类型接受实现了adder接口的对象（函数或结构体）func process(a adder) &#123;   fmt.Println(&quot;process:&quot;, a.add(&quot;taozs&quot;))&#125;//另一个函数定义func doubler(name string) int &#123;   return len(name) * 2&#125;//非函数类型type myint int//实现了adder接口func (i myint) add(name string) int &#123;   return len(name) + int(i)&#125;func main() &#123;   //注意要成为函数对象必须显式定义handler类型   var my handler = func (name string) int &#123;   return len(name)&#125;//以下是函数或函数方法的调用fmt.Println(my(&quot;taozs&quot;))                   //调用函数fmt.Println(my.add(&quot;taozs&quot;)) //调用函数对象的方法fmt.Println(handler(doubler).add(&quot;taozs&quot;)) //doubler函数显式转换成handler函数对象然后调用对象的add方法//以下是针对接口adder的调用process(my) //process函数需要adder接口类型参数process(handler(doubler)) //因为process接受的参数类型是handler，所以这儿要强制转换process(myint(8)) //实现adder接口不仅可以是函数也可以是结构体&#125;\n\n","categories":["后端"],"tags":["GO"]},{"title":"js导出execl","url":"/2023/01/30/js%E5%AF%BC%E5%87%BAexecl/","content":"使用库Sheet.js\n参考：纯前端多个sheet导出\n\n\n存在问题：createObjectURL 在 Chrome 中返回未定义\n解决方案：使用blob = window.webkitURL.createObjectURL(blob) 代替 blob = URL.createObjectURL(blob)\n\n\n\nURL.createObjectURL(blob)在本地使用不会存在问题，但如果是代码是部署在远程服务器上就不可使用，会造成内存泄漏。参考：https://developer.mozilla.org/en/DOM/window.URL.createObjectURL\n\n\n简单样例\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;    &lt;title&gt;展示 用xlsx库 导出excel，含多个sheet&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;展示 用xlsx库 导出excel，含多个sheet&lt;/h1&gt;    &lt;button id=&quot;export&quot; style=&quot;padding:20px;background: #69f;color:#fff;&quot; onclick=&quot;downloadExcel()&quot;&gt; 导出excel&lt;/button&gt;       &lt;script src=&quot;https://unpkg.com/xlsx/dist/xlsx.core.min.js&quot;&gt;&lt;/script&gt;\t    &lt;script&gt;      // 将workbook装化成blob对象     function workbook2blob(workbook) &#123;         // 生成excel的配置项         var wopts = &#123;             // 要生成的文件类型             bookType: &quot;xlsx&quot;,             // // 是否生成Shared String Table，官方解释是，如果开启生成速度会下降，但在低版本IOS设备上有更好的兼容性             bookSST: false,             type: &quot;binary&quot;         &#125;;         var wbout = XLSX.write(workbook, wopts);         // 将字符串转ArrayBuffer                 var blob = new Blob([s2ab(wbout)], &#123;             type: &quot;application/octet-stream&quot;         &#125;);         return blob;     &#125;     function s2ab(s) &#123;         var buf = new ArrayBuffer(s.length);         var view = new Uint8Array(buf);         for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xff;         return buf;     &#125;         // 将blob对象创建bloburl，然后用a标签实现弹出下载框     function openDownloadDialog(blob, fileName) &#123;         if (typeof blob == &quot;object&quot; &amp;&amp; blob instanceof Blob) &#123;             // 在远程时使用 window.webkitURL.createObjectURL()             // 为当前页面内存中的文件创建一个地址             blob = URL.createObjectURL(blob); // 创建blob地址         &#125;         var aLink = document.createElement(&quot;a&quot;);         aLink.href = blob;         // HTML5新增的属性，指定保存文件名，可以不要后缀，注意，有时候 file:///模式下不会生效         aLink.download = fileName || &quot;&quot;;         var event;         if (window.MouseEvent) event = new MouseEvent(&quot;click&quot;);         //   移动端         else &#123;             event = document.createEvent(&quot;MouseEvents&quot;);             event.initMouseEvent( &quot;click&quot;, true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null );         &#125;         aLink.dispatchEvent(event);     &#125;\t function downloadExcel()&#123;\t debugger;\t\t // 用的例子\t\t let sheet1data = [ &#123; department: &quot;行政部&quot;, count: 2 &#125;, &#123; department: &quot;前端部&quot;, count: 2 &#125; ];\t\t let sheet2data = [ &#123; name: &quot;张三&quot;, do: &quot;整理文件&quot; &#125;, &#123; name: &quot;李四&quot;, do: &quot;打印&quot; &#125; ];\t\t let sheet3data = [ &#123; name: &quot;张大人&quot;, do: &quot;vue&quot; &#125;, &#123; name: &quot;李大人&quot;, do: &quot;react&quot; &#125; ];\t\t var sheet1 = XLSX.utils.json_to_sheet(sheet1data);\t\t var sheet2 = XLSX.utils.json_to_sheet(sheet2data);\t\t var sheet3 = XLSX.utils.json_to_sheet(sheet3data);\t\t \t\t /* create a new blank workbook */\t\t var wb = XLSX.utils.book_new();\t\t XLSX.utils.book_append_sheet(wb, sheet1, &quot;部门统计&quot;);\t\t XLSX.utils.book_append_sheet(wb, sheet2, &quot;行政部&quot;);\t\t XLSX.utils.book_append_sheet(wb, sheet3, &quot;前端部&quot;);\t\t const workbookBlob = workbook2blob(wb);\t\t openDownloadDialog(workbookBlob, `部门统计.xlsx`);\t&#125;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n实例代码\n\nfunction exportFile(sheetData, fileName) &#123;       var arr = new Array(); // 将json数组转换为数组    var colWidths = [20,20,20,20,20,20,20];// 存放每一列的最大宽度    arr[0] = [&#x27;费用类型&#x27;,&#x27;明细项目&#x27;,&#x27;本月预算&#x27;,&#x27;本月折算&#x27;,&#x27;本月预算备注说明&#x27;,&#x27;上月实际&#x27;,&#x27;上月实际备注说明&#x27;]// excel的表头    sheetData.forEach(function(val,index,array)&#123;        // 构建二位数组         arr[index + 1] = new Array();        arr[index + 1][0] = val[&quot;CostForType&quot;]        arr[index + 1][1] = val[&quot;CostFor&quot;]        arr[index + 1][2] = val[&quot;MonthBudget&quot;]        arr[index + 1][3] = val[&quot;MonthConversion&quot;]        arr[index + 1][4] = val[&quot;BudgetRemarks&quot;]        arr[index + 1][5] = val[&quot;LastMonthActual&quot;]        arr[index + 1][6] = val[&quot;ActualRemarks&quot;]        colWidths[0] = Math.max(colWidths[0],getCellWidth(val[&quot;CostForType&quot;]))        colWidths[1] = Math.max(colWidths[1],getCellWidth(val[&quot;CostFor&quot;]))        colWidths[2] = Math.max(colWidths[2],getCellWidth(val[&quot;MonthBudget&quot;]))        colWidths[3] = Math.max(colWidths[3],getCellWidth(val[&quot;MonthConversion&quot;]))        colWidths[4] = Math.max(colWidths[4],getCellWidth(val[&quot;BudgetRemarks&quot;]))        colWidths[5] = Math.max(colWidths[5],getCellWidth(val[&quot;LastMonthActual&quot;]))        colWidths[6] = Math.max(colWidths[6],getCellWidth(val[&quot;ActualRemarks&quot;]))          &#125;)      console.log(colWidths)    var ws_name = &quot;Sheet1&quot;; //Excel第一个sheet的名称    var wb = XLSX.utils.book_new(); // new一个工作薄    var ws = XLSX.utils.aoa_to_sheet(arr,&#123; raw: true&#125;);    /*var ws = XLSX.utils.json_to_sheet(sheetData); // json数据转换为sheet所需的array格式数据 */    //console.log(ws)    // 设置宽度    ws[&#x27;!cols&#x27;] = []    colWidths.forEach((val,index) =&gt;&#123;        ws[&#x27;!cols&#x27;].push(&#123;wch:val&#125;)    &#125;)    XLSX.utils.book_append_sheet(wb, ws, ws_name);  //将数据添加到工作薄           const workbookBlob = workbook2blob(wb);    openDownloadDialog(workbookBlob, `部门统计.xlsx`);&#125; // 将workbook装化成blob对象function workbook2blob(workbook) &#123;    // 生成excel的配置项    var wopts = &#123;        // 要生成的文件类型        bookType: &quot;xlsx&quot;,        // // 是否生成Shared String Table，官方解释是，如果开启生成速度会下降，但在低版本IOS设备上有更好的兼容性        bookSST: false,        type: &quot;binary&quot;    &#125;;    var wbout = XLSX.write(workbook, wopts);    // 将字符串转ArrayBuffer        var blob = new Blob([s2ab(wbout)], &#123;        type: &quot;application/octet-stream&quot;    &#125;);    return blob;&#125; function s2ab(s) &#123;    var buf = new ArrayBuffer(s.length);    var view = new Uint8Array(buf);    for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xff;    return buf;&#125;    // 将blob对象创建bloburl，然后用a标签实现弹出下载框function openDownloadDialog(blob, fileName) &#123;    debugger    if (typeof blob == &quot;object&quot; &amp;&amp; blob instanceof Blob) &#123;        blob = window.webkitURL.createObjectURL(blob)        //blob = URL.createObjectURL(blob); // 创建blob地址    &#125;    var aLink = document.createElement(&quot;a&quot;);    aLink.href = blob;    // HTML5新增的属性，指定保存文件名，可以不要后缀，注意，有时候 file:///模式下不会生效    aLink.download = fileName || &quot;&quot;;    var event;    if (window.MouseEvent) event = new MouseEvent(&quot;click&quot;);    //   移动端    else &#123;        event = document.createEvent(&quot;MouseEvents&quot;);        event.initMouseEvent( &quot;click&quot;, true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null );    &#125;    aLink.dispatchEvent(event);&#125;  // 获取一个合适宽度的函数function getCellWidth(value) &#123;    // 判断是否为null或undefined    if (value == null) &#123;        return 10;    &#125; else if (/.*[\\u4e00-\\u9fa5]+.*$/.test(value)) &#123;        // 中文的长度        const chineseLength = value.match(/[\\u4e00-\\u9fa5]/g).length;        // 其他不是中文的长度        const otherLength = value.length - chineseLength;        return chineseLength * 2.1 + otherLength * 1.1;    &#125; else &#123;        return value.toString().length * 1.1;        /* 另一种方案        value = value.toString()        return value.replace(/[\\u0391-\\uFFE5]/g, &#x27;aa&#x27;).length        */    &#125;&#125;\n\n使用\nvar data = JSON.parse(ko.toJSON(KStarForm.koContentModel.TAllCostItem()))const fileName = &quot;test.xlsx&quot;exportFile(data,fileName)\n\n","categories":["前端"],"tags":["JS execl"]},{"title":"vue起步","url":"/2022/08/21/vue%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/","content":"VUE – 起步\nTime : 2022-08-02 10:04:29\n中文学习官网 : https://staging-cn.vuejs.org/\n\n\n一.构建工具Vite1.推荐使用Vite而非Vue Cli，效率更快# 通过在后添加参数，可以指定项目名称和想使用的模板npm create vite@latest\n\n\n2.index.html和项目根目录\n你可能已经注意到，在一个 Vite 项目中，index.html 在项目最外层而不是在 public 文件夹内。\n这是有意而为之的：在开发期间 Vite 是一个服务器，而 index.html 是该 Vite 项目的入口文件。\nVite 将 index.html 视为源码和模块图的一部分。\nVite 解析 &lt;script type=&quot;module&quot; src=&quot;...&quot;&gt; ，这个标签指向你的 JavaScript 源码。\n甚至内联引入 JavaScript 的 &lt;script type=&quot;module&quot;&gt; 和引用CSS的 &lt;link href&gt; 也能利用 Vite 特有的功能被解析。\n另外，index.html 中的 URL 将被自动转换，因此不再需要 %PUBLIC_URL% 占位符了。\n与静态 HTTP 服务器类似，Vite 也有 “根目录” 的概念，即服务文件的位置，在接下来的文档中你将看到它会以 &lt;root&gt; 代称。\n源码中的绝对 URL 路径将以项目的 “根” 作为基础来解析，因此你可以像在普通的静态文件服务器上一样编写代码（并且功能更强大！）。\nVite 还能够处理依赖关系，解析处于根目录外的文件位置，这使得它即使在基于 monorepo 的方案中也十分有用。\nVite 也支持多个 .html 作入口点的 多页面应用模式。\n指定替代根目录vite 以当前工作目录作为根目录启动开发服务器。你也可以通过 vite serve some/sub/dir 来指定一个替代的根目录。\n\n3.Vite命令行操作\n可以在 npm scripts 中使用 vite 可执行文件，\nvite build\n\n或者直接使用 npx vite 运行它。\nnpx vite\n\n下面是通过脚手架创建的 Vite 项目中默认的 npm scripts\n\n\n二.前置知识了解\nES模块https://segmentfault.com/a/1190000022830394\nES6快速了解https://www.runoob.com/w3cnote/es6-concise-tutorial.html\n\n三.不使用构建工具构建不推荐在生产环境下使用\nhttps://staging-cn.vuejs.org/guide/quick-start.html#without-build-tools\n","categories":["前端"],"tags":["VUE"]},{"title":"vue语法","url":"/2022/08/21/vue%E8%AF%AD%E6%B3%95/","content":"vue语法一、单向绑定\n&#123;&#123;&#125;&#125; : 文本插值\n\n&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &#x27;Hello World!&#x27;    &#125;  &#125;&#125;&lt;/script&gt;&lt;template&gt;  &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt; &lt;/template&gt;\n\n二、动态绑定v-bind\n// 动态绑定id&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;// 动态绑定class&lt;div v-bind:class=&quot;titleClass&quot;&gt;&lt;/div&gt;\n\n\n由于其使用频繁，故存在专门的简写语法\n\n&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;titleClass&quot;&gt;&lt;/div&gt;\n\nDemo\n&lt;script&gt;export default &#123;  data() &#123;    return &#123;      titleClass: &#x27;title&#x27;    &#125;  &#125;&#125;&lt;/script&gt;&lt;template&gt;  &lt;h1 :class=&quot;titleClass&quot;&gt;Make me red&lt;/h1&gt; &lt;!-- 此处添加一个动态 class 绑定 --&gt;&lt;/template&gt;&lt;style&gt;.title &#123;  color: red;&#125;&lt;/style&gt;\n\n三、事件监听v-on\n&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;\n\n\nv-on同样存在简写语法\n\n&lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;\n\n1. 内联事件处理器\n适用于简单场景\n\nconst count = ref(0)&lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;\n\n\n在内联处理器中调用方法\nfunction say(message)&#123;\talert(message)&#125;&lt;button @click=&quot;say(hello)&quot;&gt;hello&lt;/button&gt;\n\n在内联事件处理器中访问事件参数\n\n使用特殊参数$event\n\n&lt;!-- 使用特殊的 $event 变量 --&gt;&lt;button @click=&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;&gt;  Submit&lt;/button&gt;&lt;!-- 使用内联箭头函数 --&gt;&lt;button @click=&quot;(event) =&gt; warn(&#x27;Form cannot be submitted yet.&#x27;, event)&quot;&gt;  Submit&lt;/button&gt;\n\nfunction warn(message, event) &#123;  // 这里可以访问原生事件  if (event) &#123;    event.preventDefault()  &#125;  alert(message)&#125;\n\n2. 方法事件处理器\n复杂逻辑场景\n\n&lt;script&gt;const name = ref(&#x27;jddpccz&#x27;)function greet(event)&#123;\talert(&#x27;hello $&#123;name.value&#125;&#x27;) // .value是使用组合式的取值方法    if (event)&#123;        alert(event.target.tarName)    &#125;&#125;&lt;/script&gt;&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;&lt;!-- 方法事件处理器会自动接收原生 DOM 事件并触发执行。在上面的例子中，我们能够通过被触发事件的 event.target.tagName 访问到该 DOM 元素。  --&gt;\n\n3.事件修饰符\n为v-on提供的事件修饰符\n\n\n.stop\n&lt;!-- 单击事件将停止传递 --&gt;&lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;\n\n.prevent\n&lt;!-- 提交事件将不再重新加载页面 --&gt;&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰语可以使用链式书写 --&gt;&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 也可以只有修饰符 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;\n\n.self\n&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;&lt;!-- 例如：事件处理器不来自子元素 --&gt;&lt;div @click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;\n\n.capture\n&lt;!-- 添加事件监听器时，使用 `capture` 捕获模式 --&gt;&lt;!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 --&gt;&lt;div @click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;\n\n.once\n&lt;!-- 点击事件最多被触发一次 --&gt;&lt;a @click.once=&quot;doThis&quot;&gt;&lt;/a&gt;\n\n.passive\n&lt;!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 --&gt;&lt;!-- 以防其中包含 `event.preventDefault()` --&gt;&lt;div @scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;\n\n5.按键修饰符\nVue允许在v-on或@监听按键修饰符\n\n&lt;!-- 仅在 `key` 为 `Enter` 时调用 `vm.submit()` --&gt;&lt;input @keyup.enter=&quot;submit&quot; /&gt;\n\n你可以直接使用 KeyboardEvent.key 暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。\n&lt;input @keyup.page-down=&quot;onPageDown&quot; /&gt;\n\n其它的按键别名\n\n.enter\n.tab\n.delete (捕获“Delete”和“Backspace”两个按键)\n.esc\n.space\n.up\n.down\n.left\n.right\n\n6.系统按键修饰符\n.ctrl\n.alt\n.shift\n.meta (对应win下的Windows,mac下的Command,相应其他操作系统的按键)\n\n&lt;!-- Alt + Enter --&gt;&lt;input @keyup.alt.enter=&quot;clear&quot; /&gt;&lt;!-- Ctrl + 点击 --&gt;&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;\n\n7.鼠标按键修饰符\n.left\n.right\n.middle\n\n8..exact 修饰符.exact 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。\n&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;\n\n四、表单绑定\n使用v-bind和v-on组合实现了输入元素与展示的双向绑定，同样，因使用频繁，vue简化为v-model,无需使用v-on的事件处理函数，会自动更新\n\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const text = ref(&#x27;&#x27;)function onInput(e) &#123;  text.value = e.target.value&#125;&lt;/script&gt;&lt;template&gt;  &lt;input :value=&quot;text&quot; @input=&quot;onInput&quot; placeholder=&quot;Type here&quot;&gt;  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;&lt;/template&gt;\n\n\n自定义组件是，可以根据v-model的规则提供参数，使得v-model生效\nhttps://staging-cn.vuejs.org/guide/components/events.html#usage-with-v-model\n\n更多表单组件\n\n指南——表单绑定\n\n五、条件渲染分别有 v-if、v-else-if、v-else\n&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;  A&lt;/div&gt;&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;  B&lt;/div&gt;&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;  C&lt;/div&gt;&lt;div v-else&gt;  Not A/B/C&lt;/div&gt;\n\nv-show：根据条件显示或隐藏\n如果希望一组元素同时依赖于一个条件判定，同时又不希望再使用一个div或其他依赖元素，可以使用&lt;template&gt;\n&lt;template v-if=&quot;ok&quot;&gt;  &lt;h1&gt;Title&lt;/h1&gt;  &lt;p&gt;Paragraph 1&lt;/p&gt;  &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt;\n\n六、列表渲染v-for\n&lt;ul&gt;    &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;        &#123;&#123; tofo.text &#125;&#125;    &lt;/li&gt;&lt;/ul&gt;\n\n\n这里的 todo 是一个局部变量，表示当前正在迭代的数组元素。它只能在 v-for 所绑定的元素上或是其内部访问，就像函数的作用域一样。\n注意，我们还给每个 todo 对象设置了唯一的 id，并且将它作为特殊的 key attribute 绑定到每个 &lt;li&gt;。key 使得 Vue 能够精确的移动每个 &lt;li&gt;，以匹配对应的对象在数组中的位置。\n\n","categories":["前端"],"tags":["VUE"]},{"title":"vue运行机制","url":"/2022/08/21/vue%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/","content":"整体流程图\n","categories":["前端"],"tags":["VUE"]},{"title":"一些JS开源库","url":"/2023/01/30/%E4%B8%80%E4%BA%9BJS%E5%BC%80%E6%BA%90%E5%BA%93/","content":"这里推荐比较常用的JS库，可以处理日常百分之90的需求，而且这些库都有较好的文档。\ncreate.js一套完整的H5游戏引擎，做2d的动画他就足够了，包括 声音加载库：sound.js，预加载库 ：preload.js，canvas动画库：ease.js，补间动画库：tween.js\nFullpage.js快速实现全屏滚动特，基于 jQuery\n\nChart.js基于 HTML5 的 JavaScript 图表库\n\nTyped.js打字效果动画库\n\nMotio用于简单但强大的基于精灵的dom动画和平移的小型 JavaScript 库，可用于背景平移，帧动画等，兼容IE6及更高版本\n\nBounce.js 创建炫酷的 CSS3 动画(2017年的库)\nfavico.js在你的网页图标上使用角标、图片或视频\n\nanimejsJavaScript动画库\n\nDay.jsJavaScript 日期处理类库，看了掘友的推荐，换成Day.js，Day.js比moment.js更加小巧\nua-device一个用于解析UA来得到用户终端信息的JS库\n\nIconParkIconPark提供了超过2000个高质量图标，并且提供了一个界面来帮你定制图标。\n\nNumeral.js一个用于格式化和处理数字的javascript库\nfilesize.jsfilesize.js提供了一种简单的方法来从数字（浮点数或整数）或字符串中获取人类可读的文件大小字符串。\n\ncheerio为服务器特别定制的，快速、灵活、实施的jQuery核心实现. 爬虫\nBetterScrollBetterScroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 iscroll 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。\nvConsole一个轻量、可拓展、针对手机网页的前端开发者调试面板。\nHammer.jsHammer 是一个开源库，可以识别由触摸、鼠标和指针事件做出的手势。它没有任何依赖关系，而且很小，只有7.34 kB 压缩 + gzip 压缩！\n","categories":["前端"],"tags":["开源库 JS"]},{"title":"8款搜索框css","url":"/2022/08/21/%E4%BC%98%E8%B4%A8%E7%9A%848%E6%AC%BEcss%E6%90%9C%E7%B4%A2%E6%A1%86/","content":"优质的8款css搜索框&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;8款纯CSS3搜索框&lt;/title&gt;    &lt;link href=&quot;http://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;    &lt;style&gt;        * &#123;            box-sizing: border-box;        &#125;        body &#123;            margin: 0;            padding: 0;            background: #494A5F;            font-weight: 500;            font-family: &quot;Microsoft YaHei&quot;,&quot;宋体&quot;,&quot;Segoe UI&quot;, &quot;Lucida Grande&quot;, Helvetica, Arial,sans-serif, FreeSans, Arimo;        &#125;        #container &#123;            width: 500px;            height: 820px;            margin: 0 auto;        &#125;        div.search &#123;padding: 30px 0;&#125;        form &#123;            position: relative;            width: 300px;            margin: 0 auto;        &#125;        input, button &#123;            border: none;            outline: none;        &#125;        input &#123;            width: 100%;            height: 42px;            padding-left: 13px;        &#125;        button &#123;            height: 42px;            width: 42px;            cursor: pointer;            position: absolute;        &#125;        /*搜索框1*/        .bar1 &#123;background: #A3D0C3;&#125;        .bar1 input &#123;            border: 2px solid #7BA7AB;            border-radius: 5px;            background: #F9F0DA;            color: #9E9C9C;        &#125;        .bar1 button &#123;            top: 0;            right: 0;            background: #7BA7AB;            border-radius: 0 5px 5px 0;        &#125;        .bar1 button:before &#123;            content: &quot;\\f002&quot;;            font-family: FontAwesome;            font-size: 16px;            color: #F9F0DA;        &#125;        /*搜索框2*/        .bar2 &#123;background: #DABB52;&#125;        .bar2 input, .bar2 button &#123;            border-radius: 3px;        &#125;        .bar2 input &#123;            background: #F9F0DA;        &#125;        .bar2 button &#123;            height: 26px;            width: 26px;            top: 8px;            right: 8px;            background: #F15B42;        &#125;        .bar2 button:before &#123;            content: &quot;\\f105&quot;;            font-family: FontAwesome;            color: #F9F0DA;            font-size: 20px;            font-weight: bold;        &#125;        /*搜索框3*/        .bar3 &#123;background: #F9F0DA;&#125;        .bar3 form &#123;background: #A3D0C3;&#125;        .bar3 input, .bar3 button &#123;            background: transparent;        &#125;        .bar3 button &#123;            top: 0;            right: 0;        &#125;        .bar3 button:before &#123;            content: &quot;\\f002&quot;;            font-family: FontAwesome;            font-size: 16px;            color: #F9F0DA;        &#125;        /*搜索框4*/        .bar4 &#123;background: #F15B42;&#125;        .bar4 form &#123;            background: #F9F0DA;            border-bottom: 2px solid #BE290E;        &#125;        .bar4 input, .bar4 button &#123;            background: transparent;        &#125;        .bar4 button &#123;            top: 0;            right: 0;        &#125;        .bar4 button:before &#123;            content: &quot;\\f178&quot;;            font-family: FontAwesome;            font-size: 20px;            color: #be290e;        &#125;        /*搜索框5*/        .bar5 &#123;background: #683B4D;&#125;        .bar5 input, .bar5 button &#123;            background: transparent;        &#125;        .bar5 input &#123;            border: 2px solid #F9F0DA;        &#125;        .bar5 button &#123;            top: 0;            right: 0;        &#125;        .bar5 button:before &#123;            content: &quot;\\f002&quot;;            font-family: FontAwesome;            font-size: 16px;            color: #F9F0DA;        &#125;        .bar5 input:focus &#123;            border-color: #311c24        &#125;        /*搜索框6*/        .bar6 &#123;background: #F9F0DA;&#125;        .bar6 input &#123;            border: 2px solid #c5464a;            border-radius: 5px;            background: transparent;            top: 0;            right: 0;        &#125;        .bar6 button &#123;            background: #c5464a;            border-radius: 0 5px 5px 0;            width: 60px;            top: 0;            right: 0;        &#125;        .bar6 button:before &#123;            content: &quot;搜索&quot;;            font-size: 13px;            color: #F9F0DA;        &#125;        /*搜索框7*/        .bar7 &#123;background: #7BA7AB;&#125;        .bar7 form &#123;            height: 42px;        &#125;        .bar7 input &#123;            width: 250px;            border-radius: 42px;            border: 2px solid #324B4E;            background: #F9F0DA;            transition: .3s linear;            float: right;        &#125;        .bar7 input:focus &#123;            width: 300px;        &#125;        .bar7 button &#123;            background: none;            top: -2px;            right: 0;        &#125;        .bar7 button:before&#123;          content: &quot;\\f002&quot;;          font-family: FontAwesome;          color: #324b4e;        &#125;        /*搜索框8*/        .bar8 &#123;background: #B46381;&#125;        .bar8 form &#123;            height: 42px;        &#125;        .bar8 input &#123;            width: 0;            padding: 0 42px 0 15px;            border-bottom: 2px solid transparent;            background: transparent;            transition: .3s linear;            position: absolute;            top: 0;            right: 0;            z-index: 2;        &#125;        .bar8 input:focus &#123;            width: 300px;            z-index: 1;            border-bottom: 2px solid #F9F0DA;        &#125;        .bar8 button &#123;            background: #683B4D;            top: 0;            right: 0;        &#125;        .bar8 button:before &#123;            content: &quot;\\f002&quot;;            font-family: FontAwesome;            font-size: 16px;            color: #F9F0DA;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;container&quot;&gt;    &lt;div class=&quot;search bar1&quot;&gt;        &lt;form&gt;            &lt;input type=&quot;text&quot; placeholder=&quot;请输入您要搜索的内容...&quot;&gt;            &lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;div class=&quot;search bar2&quot;&gt;        &lt;form&gt;            &lt;input type=&quot;text&quot; placeholder=&quot;请输入您要搜索的内容...&quot;&gt;            &lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;div class=&quot;search bar3&quot;&gt;        &lt;form&gt;            &lt;input type=&quot;text&quot; placeholder=&quot;请输入您要搜索的内容...&quot;&gt;            &lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;div class=&quot;search bar4&quot;&gt;        &lt;form&gt;            &lt;input type=&quot;text&quot; placeholder=&quot;请输入您要搜索的内容...&quot;&gt;            &lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;div class=&quot;search bar5&quot;&gt;        &lt;form&gt;            &lt;input type=&quot;text&quot; placeholder=&quot;请输入您要搜索的内容...&quot;&gt;            &lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;div class=&quot;search bar6&quot;&gt;        &lt;form&gt;            &lt;input type=&quot;text&quot; placeholder=&quot;请输入您要搜索的内容...&quot;&gt;            &lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;div class=&quot;search bar7&quot;&gt;        &lt;form&gt;            &lt;input type=&quot;text&quot; placeholder=&quot;请输入您要搜索的内容...&quot;&gt;            &lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;        &lt;/form&gt;    &lt;/div&gt;    &lt;div class=&quot;search bar8&quot;&gt;        &lt;form&gt;            &lt;input type=&quot;text&quot; placeholder=&quot;请输入您要搜索的内容...&quot;&gt;            &lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;        &lt;/form&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n","categories":["前端"],"tags":["css demo"]},{"title":"制造个人Chrome便携版","url":"/2023/01/30/%E5%88%B6%E9%80%A0%E4%B8%AA%E4%BA%BAChrome%E4%BE%BF%E6%90%BA%E7%89%88/","content":"制作便携版Chrome\n参考文章\n自己制作Chrome便携版实现多版本共存\n\n1.准备启动器 https://portableapps.com/apps/internet/google_chrome_portable\n 下载后解压拿到其中的GoogleChromePortable.exe文件\n 直接下载链接：GoogleChromePortable.exe\n2.准备Chrome的离线安装包 下载站：\n https://www.chromedownloads.net/chrome64win-stable/\n 官方只提供最新版\n https://www.google.com/intl/zh-CN/chrome/?standalone=1\n 打开后的文件为chrome.7z才是离线安装包\n3.制作便携版\n新建一个文件夹，命名随意，Chrome运行的主目录\n\n复制GoogleChromePortable.exe到这个文件夹，可更改文件名，如Chrome.exe\n\n新建App文件夹，将离线安装包中的chrom.7z解压到这个文件夹下\n\n点击Chrome.exe启动，会在同级目录下生成Data目录，与系统版本隔离\n\n\n\n \n","categories":["杂项"],"tags":["chrome"]},{"title":"微服务-概念","url":"/2022/06/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1/","content":"微服务-概念:whale:  微服务架构（通常简称为微服务）是指开发应用所用的一种架构形式。通过微服务，可将大型应用分解成多个独立的组件，其中每个组件都有各自的责任领域。在处理一个用户请求时，基于微服务的应用可能会调用许多内部微服务来共同生成其响应。\n微服务架构的定义微服务架构是一种应用架构类型，其中应用会开发为一系列服务。它提供了独立开发、部署和维护微服务架构图和服务的框架。\n在微服务架构中，每个微服务都是独立的服务，旨在容纳一种应用特性并处理离散的任务。每个微服务都通过简单的接口与其他服务通信，以解决业务问题。\n一个微服务框架的应用程序有下列特性\n每个服务都容易被取代。\n服务是以能力来组织的，例如用户界面、前端、推荐系统、账单或是物流等。\n由于功能被拆成多个服务，因此可以由不同的编程语言、数据库实现。\n架构是对称而非分层（即生产者与消费者的关系）。\n\n一个微服务框架：\n\n适用于具持续交付的软件开发流程。\n与服务导向架构（Service-Oriented Architecture）不同，后者是集成各种业务的应用程序，但微服务只属于一个应用程序。\n\n微服务架构的用途有哪些？通常，微服务可用于加快应用开发速度。使用 Java 构建的微服务架构非常常见，尤其是 Spring Boot 架构。比较微服务与面向服务的架构也很常见。它们具有相同的目标，即将单体式应用分解为更小的组件，但这些架构所用的具体方法素有不同。以下是一些微服务架构示例：\n\n网站迁移\n托管在单体式平台上的复杂网站可以迁移到云端和基于容器的微服务平台。\n\n媒体内容\n通过使用微服务架构，图片和视频资源可以存储在可扩缩的对象存储系统中，并直接提供给网站或移动设备。\n\n交易信息和帐单\n付款处理和订单可分离开来，各自作为独立的服务单元，这样即便账单服务无法正常工作，也能正常接收付款。\n\n数据处理\n微服务平台可以扩展对现有模块化数据处理服务的云端支持。\n\n\n","categories":["后端"],"tags":["微服务"]},{"title":"微服务的体系结构","url":"/2022/06/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","content":"微服务的体系结构实现微服务体系结构非常困难。任何微服务体系结构都需要解决许多问题（见下表）。下表显示了Kubernetes生态系统中的实现功能与Spring Cloud世界中的等效功能的比较。Spring Cloud生态系统值得注意的一点是，它们都是基于Java的技术，而Kubernetes是一个多语言运行时平台。\n\n\n\n微服务\nSpring Cloud与Netflix OSS\nKubernetes\n\n\n\n配置管理：微服务应用程序的配置需要从代码中进行外部化，并可以通过简单的服务调用进行检索。\nSpring Config Server、Netflix Archaius都支持基于Git存储库的配置位置。Archaius支持配置数据类型。\nKubernetes ConfigMaps通过服务公开存储在etcd中的配置。 Kubernetes Secrets支持基于服务的安全部署和敏感配置信息（例如密码，证书等）的使用。\n\n\n服务发现：维护微服务域中可用于工作的服务实例列表。\nSpring Cloud Eureka允许客户端向其注册，与注册的客户端保持心跳，并将服务名称映射到按服务名称查找服务的客户端的主机名。\nKubernetes Services提供集群内部可用的服务实例的部署时注册。Ingress是一种机制，通过这种机制，服务可以向集群之外的客户端公开。\n\n\n负载平衡：扩展分布式系统的关键是能够运行一个组件的多个实例。然后要通过负载均衡器将负载分配到这些实例上。\nSpring Cloud Ribbon为服务客户端提供跨服务实例负载平衡的能力。\nKubernetes Service提供了跨服务实例对服务进行负载平衡的能力。这与Ribbon提供的功能不同。\n\n\nAPI网关：微服务提供的API的粒度通常与服务客户端需要的粒度不同。API网关实现表层，并提供其他服务，如代理、协议转换和其他管理功能。\nSpring Cloud Zuul提供基于配置的API表层\nKubernetes Service和Ingress resources、Istio、Ambassador是提供南北（进出数据中心）和东西（跨数据中心或云或地区的通信）API网关功能的解决方案。\n\n\n安全问题：许多安全问题推给API网关来实现。对于分布式微服务应用程序，不重新造安全方面的轮子，允许在所有服务共享的组件中进行策略定义和实现是有意义的。\nSpring Cloud Security通过Spring Cloud Zuul解决了许多安全问题\nKubernetes生态系统提供了像Istio这样的服务网格，该网格能够通过其API网关机制提供安全性。\n\n\n集中化日志记录：拥有一个集中化的日志收集和分析基础设施来管理大量的服务非常重要——其中许多服务是以分布式方式运行的。\nELK技术栈（Elasticsearch、LogStash、Kibana）\nEFK技术栈（Elasticsearch、Fluentd、Kibana）\n\n\n集中的度量：一个可以监控单个服务和整个系统的健康和性能的集中区域对于正确的操作是必不可少的。\nSpring Spectator &amp; Atlas\nHeapster, Prometheus, &amp; Grafana\n\n\n分布式跟踪：每个进程的日志记录和度量监视都有其存在的地方，但它们都不能重构事务在跨分布式系统传播时所采用的复杂路径。分布式跟踪是微服务平台必不可少的工具。\nSpring Cloud Sleuth\nHawkular, Jaeger\n\n\n弹性和容错性：分布式系统必须能够围绕故障进行自动路由，并且能够将请求路由到提供最佳响应的服务实例。\nSpring Hystrix, Turbine, &amp; Ribbon\nHealth check, service meshes (example: Istio)\n\n\n自动伸缩和自我修复：分布式系统通过水平伸缩响应更高的负载: 平台必须检测并自动响应这些条件。此外，系统需要检测故障，并尝试自动重启，无需操作员输入。\n-\n健康检查、自我修复和自动缩放\n\n\n打包、部署和调度: 大规模系统需要健壮的包管理和部署系统来管理滚动部署或蓝绿色部署，并在必要时进行回滚。调度程序帮助确定可以根据当前条件将一组新服务部署到哪个特定的执行节点。\nSpring Boot, Apache Maven. Spring Cloud系统没有真正的调度程序。\nDocker, Rkt, Kubernetes Scheduler &amp; Deployment, Helm\n\n\n作业管理：控制无人值守的后台程序执行。\nSpring Batch\nKubernetes Jobs与Scheduled Jobs\n\n\n单例应用程序：限制特定服务作为该服务在整个系统中的唯一实例运行。\nSpring Cloud Cluster\nKubernetes Pods\n\n\n","categories":["后端"],"tags":["微服务"]},{"title":"或许需要的网站","url":"/2022/06/23/%E6%88%96%E8%AE%B8%E9%9C%80%E8%A6%81%E7%9A%84%E7%BD%91%E7%AB%99/","content":"或许需要的网站Edit时间：2022-06-23 16:45:031.软件版本发布时间https://endoflife.date/\n\n\n2.清华开源镜像站https://mirrors.tuna.tsinghua.edu.cn/\n\n\n3.阿里云开源镜像站https://developer.aliyun.com/mirror/\n\n\n4.命令未找到-command–not-foundhttps://command-not-found.com/\n\n搜索go\n\n\n5.ip诊断https://ip.skk.moe/\n\n","categories":["探索"],"tags":["网站"]},{"title":"脚手架(cli)相关","url":"/2023/01/30/%E8%84%9A%E6%89%8B%E6%9E%B6-cli-%E7%9B%B8%E5%85%B3/","content":"\n参考文章：https://juejin.cn/post/6965806284914294792\n\n相关开源库\ncommander : 完整的node.js命令行解决方案\n\nhttps://github.com/tj/commander.js\n\n\nchalk：让终端打印的字符串有更好的样式\n\nhttps://github.com/chalk/chalk\n\n\n\ninquirer：交互式命令行\n\nhttps://github.com/SBoudrias/Inquirer.js\n\n\n\nora：命令行加载动画\n\nhttps://github.com/sindresorhus/ora\n\n\n\nlog-symbols：不同颜色的状态图标\n\nhttps://github.com/sindresorhus/log-symbols\n\n\n\nfs-extra：fs模块的扩展\n\nhttps://github.com/jprichardson/node-fs-extra\n\n\ncross-spawn ：nodejs spawn和spawnSync方法的跨平台解决方案\n\nhttps://github.com/moxystudio/node-cross-spawn\n\n\nconfigstore：本地存储json文件\n\nhttps://github.com/yeoman/configstore\n\n\nejs：模板渲染编译\n\nhttps://ejs.co\n\n\n\n实践// 交互式cliconst inquirer = require(&#x27;inquirer&#x27;);// simple-gitconst git = require(&#x27;simple-git&#x27;)// ora 循环等待const ora = require(&#x27;ora&#x27;)// 定义 功能选择let fucList = [    &#123;        type: &#x27;list&#x27;,        message: &#x27;请选择功能：Push 上传 Pull 拉取 Clone 克隆&#x27;,        name: &#x27;fuc&#x27;,        default: 0, //这里的默认为选择项的默认选择项 以0 开始        choices: [            &#123;                value: 1,                name: &#x27;Push本地&#x27;,            &#125;,            &#123;                value: 2,                name: &#x27;Push远程&#x27;,            &#125;,            &#123;                value: 3,                name: &#x27;Pull&#x27;,            &#125;,            &#123;                value: 4,                name: &#x27;测试加载&#x27;,            &#125;,        ],    &#125;,    &#123;        type: &#x27;input&#x27;,        message: &#x27;commit message(pull可忽略)&#x27;,        name: &#x27;commit&#x27;,        default: &#x27;修改&#x27;,        validate: (answer) =&gt; &#123;            if (answer.length &lt; 2) &#123;                return &#x27;提交信息不可以少于两个字符&#x27;;            &#125;            console.log();            return true;        &#125;,        // transformer: (a) =&gt; &#123; //修改显示内容但不会改动值        //     return `提交信息-&gt; $&#123;a&#125;`;        // &#125;,        // filter: (a) =&gt; &#123; //修改了值，不显示        //     return `$&#123;a&#125;`;        // &#125;,        prefix: &#x27;✨&#x27;,        // suffix: &#x27;🚀‍&#x27;,    &#125;,]// 对应项目路径 分支 仓库 当前写死let dirPath = &#x27;./&#x27;let branch = &#x27;master&#x27;let remote = &#x27;origin&#x27;inquirer.prompt(fucList)    // 收集用户答案后的回调，会以键值对的方式存储在这里    .then((answers) =&gt; &#123;        switch (answers.fuc) &#123;            case 1:                GitPushLocal(answers.commit);                break;            case 2:                GitPushRemote(answers.commit);                break;            case 3:                GitPull();                break;        &#125;        //console.log(&#x27;🚀‍~ answers&#x27;, answers);    &#125;)    // 捕获错误的回调    .catch((error) =&gt; &#123;        console.log(&#x27;🐱‍👤 ~ error&#x27;, error);    &#125;);// push 本地async function GitPushLocal(commit) &#123;    const spinner = ora(&quot;执行中..&quot;);    spinner.start();    await initGit(dirPath)        .add(&#x27;./*&#x27;)        .commit(commit)        .then(() =&gt; &#123;            spinner.succeed(&quot;成功&quot;);        &#125;)        .catch(err =&gt; &#123;            spinner.fail(&quot;失败了&quot; + err);        &#125;)    //console.log(&#x27;done&#x27;,commit)&#125;// push远程async function GitPushRemote(commit) &#123;    const spinner = ora(&quot;执行中..&quot;);    spinner.start();    await initGit(dirPath)        .add(&#x27;./*&#x27;)        .commit(commit)        .push([remote, branch])        .then(() =&gt; &#123;            spinner.succeed(&quot;成功&quot;);        &#125;)        .catch(err =&gt; &#123;            spinner.fail(&quot;失败了&quot; + err);        &#125;)    //console.log(&#x27;done&#x27;,commit)&#125;// pull拉取文件async function GitPull() &#123;    const spinner = ora(&quot;执行中..&quot;);    spinner.start();    await initGit(dirPath)        .pull([remote, branch])        .then(() =&gt; &#123;            spinner.succeed(&quot;成功&quot;);        &#125;)        .catch(err =&gt; &#123;            spinner.fail(&quot;失败了&quot; + err);        &#125;)&#125;// 根据文件路径初始化 simple-gitfunction initGit(path) &#123;    return git(path)&#125;\n\n\n","categories":["前端"],"tags":["node","cli命令行脚手架","开源库"]}]